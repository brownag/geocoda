% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulation.R
\name{gc_sim_composition}
\alias{gc_sim_composition}
\title{Simulate and Back-Transform Compositional Fields}
\usage{
gc_sim_composition(
  model,
  locations,
  nsim = 1,
  target_names = NULL,
  crs = "local",
  observed_data = NULL,
  nmax = NULL
)
}
\arguments{
\item{model}{A \code{gstat} object (typically from \code{gc_ilr_model()}).
For conditional simulation, the model \strong{must be built with the \code{data} parameter}
so that conditioning data is embedded in the model.}

\item{locations}{An \code{sf} object or data frame defining the simulation grid.
Must contain \code{x} and \code{y} columns. If a data frame is provided, it will be
converted to an sf object with coordinates in the specified CRS.}

\item{nsim}{Number of realizations (default 1).}

\item{target_names}{Character vector of original component names. If \code{NULL},
inferred from the \code{gstat} model or defaults to \code{c("comp1", "comp2", ...)}.}

\item{crs}{Coordinate reference system (default \code{"local"}).}

\item{observed_data}{An optional \code{sf} object or data frame containing observed
compositional samples for conditional simulation. Must have the same structure
as the data used to build the model: columns \code{x}, \code{y} for coordinates, and
columns for each ILR dimension named \code{ilr1}, \code{ilr2}, etc. (in ILR space).
If \code{NULL} (default), unconditional simulation is performed.}

\item{nmax}{Maximum number of nearby observations to use for prediction at each
location (default \code{NULL}, uses all observations). Setting a smaller \code{nmax}
(e.g., 12-15) can:
\itemize{
\item Improve computational efficiency for large datasets
\item Reduce memory usage during prediction
\item Create more local uncertainty estimates (Screen Effect)
\item May introduce slight artifacts at spatial boundaries
}

Recommended: Use \code{NULL} for small/medium datasets, \code{nmax=12-20} for large datasets.}
}
\value{
A \code{terra::SpatRaster} with layers named according to the pattern:
\verb{<component>.sim<N>} where \code{component} is from \code{target_names} and
\verb{sim<N>} indicates the realization number. For example, with 3 components
and 2 realizations: \verb{comp1.sim1, comp2.sim1, comp3.sim1, comp1.sim2, ...}
}
\description{
Generate spatial realizations of compositional data by predicting in ILR space
using a gstat model, then back-transforming to the original units. Supports
both unconditional simulation (independent of data) and conditional simulation
(honoring observed values at sample locations). Multiple realizations are
stacked into a multi-layer \code{terra::SpatRaster}.
}
\details{
This function:
\enumerate{
\item Prepares spatial coordinates from \code{locations}
\item Validates \code{observed_data} if provided (must have ilr columns and xy coords)
\item Calls \code{gstat::predict()} to generate ILR values for \code{nsim} realizations.
If the model was built with conditioning data, the predictions automatically
honor that data at the sample locations.
The \code{nmax} parameter limits the neighborhood used for kriging.
\item Extracts simulated ILR columns (identified by pattern \verb{.sim<N>})
\item Groups ILR values by realization
\item Back-transforms each realization using \code{compositions::ilrInv()}
\item Rescales from 0-1 to 0-100
\item Stacks results into a single \code{SpatRaster} with proper naming
}

\strong{Conditional vs. Unconditional:}
When the model is built with \code{data = NULL}, all realizations are independent draws from the
spatial distribution (unconditional). When the model is built with \verb{data = <conditioning_data>},
all realizations are conditioned on those values: predictions at sample locations
exactly reproduce the observed values, while predictions elsewhere reflect
uncertainty updated by the conditioning data.

\strong{Important:} For conditional simulation to work, the model **must have been built
with the conditioning data embedded via the \code{data} parameter to \code{gc_ilr_model()}.
The \code{observed_data} parameter here is only for validation. Conditioning happens
automatically because the model was created with that data.

\strong{Neighborhood Size Effects (Screen Effect):}
When \code{nmax} is small relative to data density, kriging typically uses only
the nearest \code{nmax} observations. This can create more localized uncertainty
estimates and may accelerate computation, but can also:
\itemize{
\item Introduce discontinuities at boundaries between neighborhoods
\item Miss spatial structure information from distant data
\item Bias predictions if far-field data carries important variance information
}

The output strictly honors the sum constraint: all rows sum to \code{target_sum}
(typically 100 for percentages) within floating-point precision.
}
\examples{
\dontrun{
library(sf)
library(gstat)

# Assuming ilr_params and model are already defined
# (See workflow example in the package README)

# Create simulation grid
x.range <- seq(0, 100, by = 5)
y.range <- seq(0, 100, by = 5)
grid_df <- expand.grid(x = x.range, y = y.range)

# Unconditional simulation: 5 realizations
result <- gc_sim_composition(model, grid_df, nsim = 5,
                             target_names = c("sand", "silt", "clay"))
print(result)

# Conditional simulation: honor observed data
result_cond <- gc_sim_composition(model, grid_df, nsim = 5,
                                  target_names = c("sand", "silt", "clay"),
                                  observed_data = sample_df)

# Large dataset: use neighborhood limiting for efficiency
result_nmax <- gc_sim_composition(model, grid_df, nsim = 5,
                                  target_names = c("sand", "silt", "clay"),
                                  nmax = 15)

# Access results
terra::values(result)
}

}
