% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulation.R
\name{gc_sim_composition_block}
\alias{gc_sim_composition_block}
\title{Simulate Compositional Fields at Block Support}
\usage{
gc_sim_composition_block(
  model,
  block_centers,
  block_size,
  nsim = 1,
  target_names = NULL,
  crs = "local",
  discretization = c(4, 4),
  observed_data = NULL,
  nmax = NULL
)
}
\arguments{
\item{model}{A gstat object from \code{\link[=gc_ilr_model]{gc_ilr_model()}}, optionally with MAF attributes}

\item{block_centers}{Data frame with x, y columns (block center coordinates)}

\item{block_size}{Vector c(dx, dy) specifying block dimensions (same units as coordinates)}

\item{nsim}{Number of simulations to generate (default 1)}

\item{target_names}{Character vector of target component names
(e.g., c("sand", "silt", "clay"))}

\item{crs}{Coordinate reference system (default "local")}

\item{discretization}{Vector c(nx, ny) specifying sub-points per block dimension
(default c(4, 4) = 16 sub-points per block)}

\item{observed_data}{Optional sf object with observed data (for conditioning)}

\item{nmax}{Maximum number of nearest neighbors for kriging (default NULL = all data)}
}
\value{
terra::SpatRaster stack with block-support compositional fields
\itemize{
\item Dimensions: nrow(block_centers) rows
\item Layers: sand.sim1, silt.sim1, clay.sim1, sand.sim2, ... (for each component and realization)
\item Values: 0-100 (percent/proportion scale, sum to 100 per block)
}
}
\description{
Direct block simulation (DBS) for management-scale uncertainty quantification.
Simulates block-averaged values by discretizing blocks into sub-points,
simulating at sub-point support, and averaging to block support.
}
\details{
This approach captures the volume-variance relationship: block variance
is lower than point variance due to averaging (nugget averaging effect).

\strong{Direct Block Simulation (DBS) workflow:}
\enumerate{
\item \strong{Discretization}: Each block is subdivided into regular grid of sub-points
\itemize{
\item Default: 4×4 grid = 16 sub-points per block
\item Sub-points centered within sub-cells (not at corners)
}
\item \strong{Sub-point simulation}: Simulate ILR coordinates at all sub-point locations
\itemize{
\item Uses standard Sequential Gaussian Simulation (SGS)
\item Respects spatial structure (variogram) and any conditioning data
}
\item \strong{Block averaging}: Average ILR values across sub-points within each block
\itemize{
\item For each block B and variable Z: Z_B = mean(Z_sub-points in B)
\item This averaging produces the volume-variance reduction
}
\item \strong{Back-transformation}: ILR → Composition at block support
\itemize{
\item Each block-averaged ILR coordinate set back-transforms to composition
\item Compositional constraints automatically satisfied (sums to 100)
}
}

\strong{Volume-variance relationship:}

\if{html}{\out{<div class="sourceCode">}}\preformatted{Var(Z_block) ≈ Var(Z_point) / (nx × ny)
}\if{html}{\out{</div>}}

Example: 4×4 discretization → block variance ≈ 1/16 of point variance

\strong{Computational efficiency:}
\itemize{
\item Memory: Only stores block-support results, not intermediate sub-point grids
\item Speed: One simulation run (sub-points and averaging) vs. many refinement steps
\item Practical: Enables large-scale uncertainty quantification at management units
}

\strong{Comparison to alternatives:}
\itemize{
\item vs. Point-then-aggregate: Same result but faster (direct computation)
\item vs. Block kriging: Similar math but simulation vs. estimation
\item vs. LUC (Localised Uniform Conditioning): Simpler implementation, comparable accuracy
}
}
\examples{
\dontrun{
# Setup: ILR model from previous steps
ilr_params <- gc_ilr_params(texture_data[, c("sand", "silt", "clay")])
vgm <- gc_fit_vgm(ilr_params, texture_data, aggregate = TRUE)
model <- gc_ilr_model(ilr_params, vgm)

# Create management-unit-scale grid (100m blocks)
blocks <- expand.grid(
  x = seq(0, 1000, by = 100),
  y = seq(0, 1000, by = 100)
)

# Block simulation with 4×4 discretization (16 sub-points per block)
block_sims <- gc_sim_composition_block(
  model = model,
  block_centers = blocks,
  block_size = c(100, 100),
  nsim = 10,
  target_names = c("sand", "silt", "clay"),
  discretization = c(4, 4)
)

# Result: 10 blocks × 3 components × 10 sims = 300 layers
print(block_sims)

# Check volume-variance relationship
point_variance <- terra::global(
  gc_sim_composition(model, blocks, nsim = 10),
  "sd"
)
block_variance <- terra::global(block_sims, "sd")
# block_variance should be ~1/4 of point_variance (for 4×4 grid)
}

}
