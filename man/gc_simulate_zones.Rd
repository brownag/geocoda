% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/zonal_simulation.R
\name{gc_simulate_zones}
\alias{gc_simulate_zones}
\title{Simulate Compositional Data Within Vector or Raster Zones}
\usage{
gc_simulate_zones(
  zone_models,
  zones,
  extent,
  resolution,
  nsim = 1,
  nmax = NULL,
  edge_handling = "buffer",
  buffer_distance = NA,
  fill_gaps = TRUE,
  validate_constraints = TRUE,
  rescale_to_target = TRUE,
  verbose = TRUE
)
}
\arguments{
\item{zone_models}{A list from \code{gc_fit_zone_models()} with fitted models per zone.}

\item{zones}{An sf object (polygons) or terra::SpatRaster defining zone boundaries.}

\item{extent}{An sf object or terra::SpatRaster defining the full simulation extent.}

\item{resolution}{Numeric. Grid cell size (in map units, typically meters).}

\item{nsim}{Numeric. Number of realizations per zone (default 1).}

\item{nmax}{Numeric. Maximum number of neighbors for kriging. If NULL (default),
uses all available observations per zone. Smaller values (12-20) improve speed
for large datasets but may introduce edge effects.}

\item{edge_handling}{Character. Strategy for zone boundaries. Options:
\itemize{
\item \code{"buffer"} (default): Expand grid by 10\% buffer before simulation, then clip
\item \code{"clip"}: Strict boundary clip; may lose edge information
\item \code{"overlap"}: Allow 1-cell overlap between zones for smooth transitions
}}

\item{fill_gaps}{Logical. If TRUE (default), fill any gaps/slivers with values
from nearest zone via simple nearest-neighbor interpolation.}

\item{validate_constraints}{Logical. If TRUE (default), validate sum constraints
post-stitching and issue warnings if violated.}

\item{verbose}{Logical. Print progress messages (default TRUE).}
}
\value{
A terra::SpatRaster with layer names \verb{<component>.<zone_id>.sim<N>}.
E.g., for 3 components (sand, silt, clay) and 2 realizations in 4 zones,
output has 24 layers:
\verb{sand.1.sim1, silt.1.sim1, clay.1.sim1, sand.1.sim2, ..., clay.4.sim2}

Attributes:
\itemize{
\item \code{zone_extent}: Bounding box of all zones
\item \code{resolution}: Grid resolution used
\item \code{n_zones}: Number of zones simulated
\item \code{n_realizations}: Number of realizations per zone
}
}
\description{
Generate spatial realizations of compositional data for each zone independently,
then stitch results into a seamless tessellation covering the full extent.
}
\details{
\strong{Per-Zone Workflow:}
\enumerate{
\item Create simulation grid within zone boundary (plus optional buffer)
\item Call \code{gc_sim_composition()} for this zone's model
\item Validate sum constraints within zone
\item Clip results to zone boundary (if edge_handling != "overlap")
}

\strong{Stitching Algorithm:}
\enumerate{
\item Merge all zone rasters
\item Detect and handle overlaps (if any) using edge_handling strategy
\item Fill remaining gaps from nearest non-NA cell
\item Validate global sum constraints
}

\strong{Performance Notes:}
\itemize{
\item For 100+ zones at 30m resolution: expect 5-10 min on typical machine
\item Use \code{nmax=15} for large datasets (> 1000 samples per zone)
}
}
\examples{
\dontrun{
# Simulate 5 realizations across 3 zones
zone_models <- gc_fit_zone_models(zone_data)
result <- gc_simulate_zones(
  zone_models = zone_models,
  zones = zones_sf,
  extent = zones_sf,
  resolution = 30,
  nsim = 5
)

# Access individual realization
terra::plot(result[[1]])  # First component, all zones, first realization
}

}
