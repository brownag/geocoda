[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 geocoda authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/soil_texture_workflow.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Soil Texture Workflow","text":"vignette demonstrates workflow spatially simulating soil texture separates (Sand, Silt, Clay) using geocoda package. Soil texture compositional variable; components must sum exactly 100%. sum constraint violates standard statistical assumptions (e.g., variables treated independent), making conventional multivariate geostatistics inappropriate. Isometric Log-Ratio (ILR) transformation one principled approach designed specifically compositional data: removes sum constraint, allowing standard multivariate geostatistics applied transformed space. Back-transformation simulation results guarantees realizations sum 100% remain non-negative. workflow uses ILR transformations; however, transformations (e.g., Centered Log-Ratio Additive Log-Ratio) offer different properties may suitable depending analytical goal. framework generic applicable DD-part composition (geochemistry, vegetation classes, mineral assemblages, etc.). workflow follows five key steps: Constrain - Define valid ranges soil fine-earth fraction components Transform - Convert ILR space eliminate sum constraint Model - Fit Linear Model Coregionalization (LMC) using covariance structure spatial variograms Simulate - Generate spatial realizations ILR space Back-transform - Return original units, preserving 100% constraint","code":""},{"path":[]},{"path":"/articles/soil_texture_workflow.html","id":"setup-and-load-packages","dir":"Articles","previous_headings":"Data Preparation and Analysis","what":"Setup and Load Packages","title":"Soil Texture Workflow","text":"","code":"library(geocoda) library(gstat) library(sf) library(terra)  # Set seed for reproducibility set.seed(42)"},{"path":"/articles/soil_texture_workflow.html","id":"define-composition-constraints","dir":"Articles","previous_headings":"Data Preparation and Analysis","what":"Define Composition Constraints","title":"Soil Texture Workflow","text":"Start defining realistic bounds soil texture components. constraints represent plausible range values expect simulate. example uses typical silt loam bounds: sand clay restricted narrow ranges, silt filling remainder sum 100%.","code":"constraints <- list(   SAND = list(min = 0, max = 40),   SILT = list(min = 50, max = 80),   CLAY = list(min = 10, max = 20) )"},{"path":"/articles/soil_texture_workflow.html","id":"generate-valid-composition-grid","dir":"Articles","previous_headings":"Data Preparation and Analysis","what":"Generate Valid Composition Grid","title":"Soil Texture Workflow","text":"Expand constraints grid physically valid combinations sum exactly 100%. exploration, coarse grids (0.5-1% resolution) usually sufficient, though finer grids allow detailed compositions higher computational cost. 1% resolution, get nrow(grid) valid compositions. Let’s check first : rows sum 100% within floating-point tolerance:","code":"grid <- gc_expand_bounds(constraints, step = 1.0, target_sum = 100) head(grid) #>   SAND SILT CLAY #> 1   40   50   10 #> 2   39   51   10 #> 3   38   52   10 #> 4   37   53   10 #> 5   36   54   10 #> 6   35   55   10 all(abs(rowSums(grid) - 100) < 1e-6) #> [1] TRUE"},{"path":"/articles/soil_texture_workflow.html","id":"bootstrap-samples-from-valid-compositions","dir":"Articles","previous_headings":"Data Preparation and Analysis","what":"Bootstrap Samples from Valid Compositions","title":"Soil Texture Workflow","text":"Sample valid composition grid create representative sample population. can use uniform random sampling soil texture-aware methods (aqp available). soil texture-aware sampling respects texture class boundaries, use method = \"soil_texture\" aqp package installed. Check sample statistics:","code":"samples <- gc_resample_compositions(   grid,   n = 1000,   method = \"uniform\" ) data.frame(   Component = c(\"SAND\", \"SILT\", \"CLAY\"),   Mean = colMeans(samples$samples),   StdDev = apply(samples$samples, 2, sd),   Min = apply(samples$samples, 2, min),   Max = apply(samples$samples, 2, max) ) #>      Component   Mean   StdDev Min Max #> SAND      SAND 20.124 9.352438   0  40 #> SILT      SILT 65.029 8.949987  50  80 #> CLAY      CLAY 14.847 3.043494  10  20"},{"path":"/articles/soil_texture_workflow.html","id":"estimate-ilr-parameters","dir":"Articles","previous_headings":"Data Preparation and Analysis","what":"Estimate ILR Parameters","title":"Soil Texture Workflow","text":"Transform sample compositions ILR space estimate mean vector covariance matrix. covariance matrix:","code":"params <- gc_ilr_params(samples$samples) params$mean #> [1]  0.9210350 -0.6840842 params$cov #>           [,1]       [,2] #> [1,] 0.2690597 0.12365761 #> [2,] 0.1236576 0.09692909"},{"path":[]},{"path":"/articles/soil_texture_workflow.html","id":"suggest-and-set-variogram-parameters","dir":"Articles","previous_headings":"Geostatistical Modeling","what":"Suggest and Set Variogram Parameters","title":"Soil Texture Workflow","text":"variogram quantifies spatial correlation measuring similarity values changes distance: γ(h)=12E[Z(x)−Z(x+h)]2\\gamma(h) = \\frac{1}{2} E[Z(x) - Z(x+h)]^2 Z(x)Z(x) represents value location xx. Key properties: distance 0: γ(0)=0\\gamma(0) = 0 (perfect similarity ) small distances: γ(h)\\gamma(h) small, indicating high correlation large distances: γ(h)\\gamma(h) approaches maximum value (sill), indicating independence Nugget effect: Often discontinuity h=0h=0, representing measurement error small-scale variation Range: distance variogram reaches sill, beyond observations uncorrelated Use helper function suggest reasonable parameters: Create variogram model using suggested range, reduce substantially better capture local features. also use small nugget preserve conditioning effect:","code":"extent <- c(0, 0, 100, 100) suggestions <- gc_vgm_defaults(params, extent) suggestions #> $range #> [1] 47.14045 #>  #> $nugget #> [1] 0.001829944 #>  #> $mean_sill #> [1] 0.1829944 vgm_model <- gstat::vgm(   psill = 1,   model = \"Exp\",   range = suggestions$range * 0.35,   nugget = 0.01 ) vgm_model #>   model psill    range #> 1   Nug  0.01  0.00000 #> 2   Exp  1.00 16.49916"},{"path":"/articles/soil_texture_workflow.html","id":"build-multivariate-geostatistical-model","dir":"Articles","previous_headings":"Geostatistical Modeling","what":"Build Multivariate Geostatistical Model","title":"Soil Texture Workflow","text":"Combine ILR covariance structure spatial variogram create joint multivariate representation: default, gc_ilr_model() uses Independent Univariate Kriging (one model per ILR dimension, cross-covariance terms). approach numerically stable standard practice. comparison, can also build Linear Model Coregionalization (LMC) cross-covariance terms specifying model_type = \"lmc\": LMC approach includes spatial correlation ILR dimensions. theoretically complete, ’s numerically complex rarely necessary given ILR transformation already decorrelates data significantly. applications, univariate approach preferred.","code":"model <- gc_ilr_model(params, variogram_model = vgm_model) model #> data: #> ilr1 : formula = ilr1`~`1 ; dummy data beta = 0.921035 #> ilr2 : formula = ilr2`~`1 ; dummy data beta = -0.6840842 #> variograms: #>         model        psill    range #> ilr1[1]   Nug 0.0026905968  0.00000 #> ilr1[2]   Exp 0.2690596802 16.49916 #> ilr2[1]   Nug 0.0009692909  0.00000 #> ilr2[2]   Exp 0.0969290870 16.49916 ## Alternative: Build LMC Model with Cross-Covariance Terms model_lmc <- gc_ilr_model(params, variogram_model = vgm_model, model_type = \"lmc\") model_lmc #> data: #> ilr1 : formula = ilr1`~`1 ; dummy data beta = 0.921035 #> ilr2 : formula = ilr2`~`1 ; dummy data beta = -0.6840842 #> variograms: #>              model        psill    range #> ilr1[1]        Nug 0.0026905968  0.00000 #> ilr1[2]        Exp 0.2690596802 16.49916 #> ilr2[1]        Nug 0.0009692909  0.00000 #> ilr2[2]        Exp 0.0969290870 16.49916 #> ilr1.ilr2[1]   Nug 0.0012365761  0.00000 #> ilr1.ilr2[2]   Exp 0.1236576104 16.49916"},{"path":[]},{"path":"/articles/soil_texture_workflow.html","id":"define-simulation-grid","dir":"Articles","previous_headings":"Spatial Simulation","what":"Define Simulation Grid","title":"Soil Texture Workflow","text":"Create regular spatial grid want simulate soil texture: creates 26×26 grid 4 unit spacing (nrow(grid_sf) cells total).","code":"x_range <- seq(0, 100, by = 4) y_range <- seq(0, 100, by = 4) grid_df <- expand.grid(x = x_range, y = y_range)  grid_sf <- sf::st_as_sf(grid_df, coords = c(\"x\", \"y\"))"},{"path":"/articles/soil_texture_workflow.html","id":"generate-spatial-realizations","dir":"Articles","previous_headings":"Spatial Simulation","what":"Generate Spatial Realizations","title":"Soil Texture Workflow","text":"Simulate multiple equally-probable realizations soil texture across domain. uncertainty quantification, use 10-20 realizations; exploratory analysis, 1-3 realizations sufficient.","code":"sims <- gc_sim_composition(   model,   grid_sf,   nsim = 3,   target_names = c(\"sand\", \"silt\", \"clay\"),   crs = \"local\" ) sims #> class       : SpatRaster  #> size        : 26, 26, 9  (nrow, ncol, nlyr) #> resolution  : 4, 4  (x, y) #> extent      : -2, 102, -2, 102  (xmin, xmax, ymin, ymax) #> coord. ref. : Cartesian (Meter)  #> source(s)   : memory #> names       : sand.sim1, silt.sim1, clay.sim1, sand.sim2, silt.sim2, clay.sim2, ...  #> min values  :  2.188856,  33.24090,  3.570206,  2.666431,  31.87933,  3.689029, ...  #> max values  : 46.666041,  92.89209, 37.131396, 45.353244,  92.85779, 37.892626, ..."},{"path":"/articles/soil_texture_workflow.html","id":"validation","dir":"Articles","previous_headings":"Spatial Simulation","what":"Validation","title":"Soil Texture Workflow","text":"Verify constraints satisfied output statistics reasonable: Check sum constraint realization: Check non-negativity:","code":"vals <- as.data.frame(terra::values(sims)) for (sim_idx in 1:3) {   col_indices <- grep(paste0(\"sim\", sim_idx), colnames(vals))   sums <- rowSums(vals[, col_indices])   cat(     \"Realization\", sim_idx, \": min =\", round(min(sums), 4),     \", max =\", round(max(sums), 4),     \", mean =\", round(mean(sums), 4), \"\\n\"   ) } #> Realization 1 : min = 100 , max = 100 , mean = 100  #> Realization 2 : min = 100 , max = 100 , mean = 100  #> Realization 3 : min = 100 , max = 100 , mean = 100 min(as.matrix(vals)) #> [1] 2.188856 max(as.matrix(vals)) #> [1] 94.33514"},{"path":"/articles/soil_texture_workflow.html","id":"summary-statistics-and-visualization","dir":"Articles","previous_headings":"Spatial Simulation","what":"Summary Statistics and Visualization","title":"Soil Texture Workflow","text":"Summary first realization: Correlation structure: Marginal distributions:","code":"first_sim <- vals[, grep(\"sim1\", colnames(vals))] summary(first_sim) #>    sand.sim1        silt.sim1       clay.sim1     #>  Min.   : 2.189   Min.   :33.24   Min.   : 3.57   #>  1st Qu.:10.534   1st Qu.:60.58   1st Qu.:11.58   #>  Median :15.211   Median :68.58   Median :15.57   #>  Mean   :16.577   Mean   :67.60   Mean   :15.83   #>  3rd Qu.:20.797   3rd Qu.:76.39   3rd Qu.:19.95   #>  Max.   :46.666   Max.   :92.89   Max.   :37.13 cor(first_sim) #>            sand.sim1  silt.sim1  clay.sim1 #> sand.sim1  1.0000000 -0.8887263  0.3789889 #> silt.sim1 -0.8887263  1.0000000 -0.7610566 #> clay.sim1  0.3789889 -0.7610566  1.0000000 apply(first_sim, 2, function(x) {   c(Mean = mean(x), SD = sd(x), Min = min(x), Max = max(x)) }) #>      sand.sim1 silt.sim1 clay.sim1 #> Mean 16.577486  67.59519 15.827322 #> SD    7.837749  11.18117  5.539084 #> Min   2.188856  33.24090  3.570206 #> Max  46.666041  92.89209 37.131396"},{"path":"/articles/soil_texture_workflow.html","id":"visualizing-results","dir":"Articles","previous_headings":"Spatial Simulation","what":"Visualizing Results","title":"Soil Texture Workflow","text":"","code":"plot(sims, main = c(   \"Sand (%)\", \"Silt (%)\", \"Clay (%)\",   \"Realization 2\", \"Realization 2\", \"Realization 2\",   \"Realization 3\", \"Realization 3\", \"Realization 3\" ))"},{"path":[]},{"path":"/articles/soil_texture_workflow.html","id":"conditional-simulation-with-observed-data","dir":"Articles","previous_headings":"Advanced Techniques","what":"Conditional Simulation with Observed Data","title":"Soil Texture Workflow","text":"practice, often field observations laboratory measurements soil texture specific locations. Conditional simulation honors observed values generating realizations unobserved locations, reducing uncertainty near samples.","code":""},{"path":"/articles/soil_texture_workflow.html","id":"prepare-conditioning-data","dir":"Articles","previous_headings":"Advanced Techniques","what":"Prepare Conditioning Data","title":"Soil Texture Workflow","text":"Create spatially-structured conditioning data simulate realistic field scenario. ’ll create observation points higher sand content along diagonal line: Transform observations ILR space:","code":"set.seed(123)  # Create observation locations along a diagonal line n_obs <- 8 t_vals <- seq(0, 1, length.out = n_obs) obs_coords <- data.frame(   x = 20 + 60 * t_vals,   y = 20 + 60 * t_vals )  # Assign sandy loam compositions with measurement variation obs_comps <- list() for (i in 1:nrow(obs_coords)) {   base_comp <- c(SAND = 60, SILT = 25, CLAY = 15)   noise <- rnorm(3, mean = 0, sd = 2)   obs_comp <- pmax(pmin(base_comp + noise, 100), 0)   obs_comp <- obs_comp / sum(obs_comp) * 100   obs_comps[[i]] <- obs_comp } obs_samples <- as.data.frame(do.call(rbind, obs_comps)) obs_ilr <- compositions::ilr(compositions::acomp(obs_samples)) colnames(obs_ilr) <- c(\"ilr1\", \"ilr2\")  conditioning_data <- sf::st_as_sf(   data.frame(x = obs_coords$x, y = obs_coords$y, obs_ilr),   coords = c(\"x\", \"y\") ) conditioning_data #> Simple feature collection with 8 features and 2 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 20 ymin: 20 xmax: 80 ymax: 80 #> CRS:           NA #>         ilr1       ilr2                  geometry #> 1 -0.6188566 -0.6050353             POINT (20 20) #> 2 -0.6134338 -0.6115086 POINT (28.57143 28.57143) #> 3 -0.7052796 -0.8155840 POINT (37.14286 37.14286) #> 4 -0.5424064 -0.7682648 POINT (45.71429 45.71429) #> 5 -0.6222000 -0.8463847 POINT (54.28571 54.28571) #> 6 -0.6323449 -1.0623600 POINT (62.85714 62.85714) #> 7 -0.6626548 -0.8935953 POINT (71.42857 71.42857) #> 8 -0.6744539 -0.8200314             POINT (80 80)"},{"path":"/articles/soil_texture_workflow.html","id":"build-model-with-conditioning-data","dir":"Articles","previous_headings":"Advanced Techniques","what":"Build Model with Conditioning Data","title":"Soil Texture Workflow","text":"model switches kriging mode conditioning data provided:","code":"model_conditional <- gc_ilr_model(   ilr_params = params,   variogram_model = vgm_model,   data = conditioning_data ) model_conditional #> data: #> ilr1 : formula = ilr1`~`1 ; data dim = 8 x 2 beta = 0.921035 #> ilr2 : formula = ilr2`~`1 ; data dim = 8 x 2 beta = -0.6840842 #> variograms: #>         model        psill    range #> ilr1[1]   Nug 0.0026905968  0.00000 #> ilr1[2]   Exp 0.2690596802 16.49916 #> ilr2[1]   Nug 0.0009692909  0.00000 #> ilr2[2]   Exp 0.0969290870 16.49916"},{"path":"/articles/soil_texture_workflow.html","id":"simulate-with-conditioning","dir":"Articles","previous_headings":"Advanced Techniques","what":"Simulate with Conditioning","title":"Soil Texture Workflow","text":"Perform conditional simulation. Since model built conditioning data, automatically honors values prediction: comparison, also generate unconditional simulation grid parameters:","code":"sims_conditional <- gc_sim_composition(   model = model_conditional,   locations = grid_sf,   nsim = 1,   target_names = c(\"sand\", \"silt\", \"clay\"),   crs = \"local\",   observed_data = conditioning_data ) sims_unconditional <- gc_sim_composition(   model = model,   locations = grid_sf,   nsim = 1,   target_names = c(\"sand\", \"silt\", \"clay\"),   crs = \"local\" )"},{"path":"/articles/soil_texture_workflow.html","id":"verification","dir":"Articles","previous_headings":"Advanced Techniques","what":"Verification","title":"Soil Texture Workflow","text":"Extract predicted values observation locations: Conditional kriging successfully reproduces observed sand values sample locations, errors ±2%. Visualize simulations side--side:  hollow circles mark observation locations. conditional simulation shows clear influence measurements, sand content concentrated near diagonal line observations placed.","code":"extracted <- terra::extract(sims_conditional, conditioning_data)  comparison <- data.frame(   Observed = obs_samples$SAND,   Predicted = extracted$sand.sim1,   Error = extracted$sand.sim1 - obs_samples$SAND )  comparison #>   Observed Predicted         Error #> 1 57.98828  57.98828  7.105427e-15 #> 2 57.92274  61.88335  3.960612e+00 #> 3 62.79436  63.86238  1.068024e+00 #> 4 57.79304  65.52629  7.733252e+00 #> 5 60.85557  60.97899  1.234216e-01 #> 6 63.17187  65.28832  2.116454e+00 #> 7 62.45096  50.24221 -1.220875e+01 #> 8 62.01084  62.01084 -7.105427e-15 par(mfrow = c(1, 2)) plot(sims_unconditional[[\"sand.sim1\"]], main = \"Unconditional: Sand\") plot(sims_conditional[[\"sand.sim1\"]], main = \"Conditional: Sand (Diagonal Observations)\") cond_coords <- sf::st_coordinates(conditioning_data) points(cond_coords[, 1], cond_coords[, 2], pch = 1, cex = 2, col = \"black\", lwd = 2) par(mfrow = c(1, 1))"},{"path":"/articles/soil_texture_workflow.html","id":"understanding-conditional-simulation","dir":"Articles","previous_headings":"Advanced Techniques","what":"Understanding Conditional Simulation","title":"Soil Texture Workflow","text":"Conditional simulation differs fundamentally unconditional simulation uses data. Unconditional simulation ignores observations samples marginal distribution everywhere, producing uniformly high uncertainty. Conditional simulation incorporates observed values sample locations, reducing uncertainty vicinity measurements. Away observations, uncertainty gradually increases distance. Choose unconditional simulation explore regional patterns without anchoring specific measurements. Use conditional simulation whenever field observations measurements inform predictions. Conditioning reduces uncertainty near measurement locations improves reliability decision-making based realizations.","code":""},{"path":"/articles/soil_texture_workflow.html","id":"handling-zeros-and-censored-data","dir":"Articles","previous_headings":"Advanced Techniques","what":"Handling Zeros and Censored Data","title":"Soil Texture Workflow","text":"Real-world compositional data often contains zeros (non-detected values, trace components) -detection-limit (censored) measurements. Zeros problematic geometric mean undefined, making standard covariance analysis unstable. gc_handle_zeros() function addresses using log-ratio-based imputation methods.","code":""},{"path":"/articles/soil_texture_workflow.html","id":"zero-imputation-strategies","dir":"Articles","previous_headings":"Advanced Techniques","what":"Zero Imputation Strategies","title":"Soil Texture Workflow","text":"package provides three imputation approaches, accessible via method parameter: mzero (multiplicative zero replacement): Fast, replaces zeros small multiple detection limit azero (additive zero replacement): Conservative, adds small constant values lrem (log-ratio EM): Probabilistic, uses expectation-maximization log-ratio space soil texture data isolated zeros, mzero typically sufficient. many zeros (>30% values), lrem principled. Example zeros soil texture data: imputed_data component ready use analysis (transformation, covariance estimation, etc.). datasets censored measurements known detection limits:","code":"# Create data with some zeros soil_with_zeros <- data.frame(   SAND = c(40, 35, 0, 42, 38),   SILT = c(35, 40, 45, 36, 40),   CLAY = c(25, 25, 55, 22, 22) )  # Impute using multiplicative zero replacement (default) imputation_result <- gc_handle_zeros(soil_with_zeros, method = \"mzero\")  print(imputation_result$imputed_data) print(paste(\"Imputation rate:\", round(imputation_result$imputation_rate, 4))) print(paste(\"Rows imputed:\", sum(imputation_result$row_status == \"imputed\"))) # Define detection limits for each component detection_limits <- c(SAND = 1, SILT = 1, CLAY = 1)  # Use log-ratio EM for censored data result_lrem <- gc_handle_zeros(   soil_with_zeros,   method = \"lrem\",   dl = detection_limits )"},{"path":"/articles/soil_texture_workflow.html","id":"data-quality-diagnostics","dir":"Articles","previous_headings":"Advanced Techniques","what":"Data Quality Diagnostics","title":"Soil Texture Workflow","text":"building kriging model conditioning data, assess well model honors observations using gc_validate_conditioning(). Error Metrics Interpretation: - RMSE: Root mean squared error; smaller better (ideally < 0.01 ILR space) - MAE: Mean absolute error; typical values 0.5-2% composition space - Mean_Error: Signed bias; close zero - Median_Error: Robustness outliers Non-zero residuals can indicate: - Numerical precision effects (typically < 1e-10 ILR space) - Model convergence issues (switch univariate kriging problematic) - Grid resolution effects (predictions coarse grids may miss exact locations) compositional back-transformation, residuals ILR space can converted composition space using ilrInv() interpretation original units.","code":"## Validation compares predictions at observation locations to actual values validation <- gc_validate_conditioning(model, conditioning_data)  # Review error metrics print(validation$error_metrics) print(validation$overall_metrics)  # Check for problematic observations high_residuals <- which(abs(validation$residuals$ilr1) > 0.1) if (length(high_residuals) > 0) {   print(\"Observations with large residuals:\")   print(validation$residuals[high_residuals, ]) }"},{"path":"/articles/soil_texture_workflow.html","id":"lmc-stability-and-admissibility","dir":"Articles","previous_headings":"Advanced Techniques","what":"LMC Stability and Admissibility","title":"Soil Texture Workflow","text":"using LMC approach (model_type = \"lmc\"), positive-definiteness covariance structure critical. gc_fit_vgm() function now includes enhanced diagnostics via correct.diagonal parameter (default 1.01). correct.diagonal parameter multiplies marginal sill small factor improve numerical stability: model produces singular matrix errors simulation, increase correct.diagonal 1.02-1.05, switch univariate kriging (model_type = \"univariate\", default) better numerical stability.","code":"# Use enhanced variogram fitting with LMC diagnostics fitted_vgm <- gc_fit_vgm(   ilr_params,   data = sample_locations_with_ilr,   aggregate = TRUE,   correct.diagonal = 1.01  # Default: slight diagonal inflation )  # Check LMC admissibility lmc_admissible <- attr(fitted_vgm, \"lmc_admissibility\") if (!lmc_admissible) {   warning(\"LMC sill matrix may not be positive-definite\") }"},{"path":"/articles/soil_texture_workflow.html","id":"comparing-univariate-vs-multivariate-modeling","dir":"Articles","previous_headings":"Advanced Techniques","what":"Comparing Univariate vs Multivariate Modeling","title":"Soil Texture Workflow","text":"conditional simulation now understood, can compare two modeling approaches practice. see univariate LMC models differ, run conditional simulations compare results. Create observation data: Build conditional models approaches: Create fine grid simulation: Simulate models: Visual comparison:  Numerical comparison observation locations: approaches produce similar results observation locations. univariate model achieves mean absolute error ~2.8% maximum error ~10.9%, LMC model shows mean absolute error ~3.0% maximum error ~9.4%. differences negligible practical purposes, confirming simpler univariate approach adequate. univariate method preferred numerical stability, computational efficiency, ease interpretation.","code":"set.seed(456)  # Create observation locations along a diagonal n_obs <- 10 t_vals <- seq(0, 1, length.out = n_obs) obs_coords <- data.frame(   x = 10 + 80 * t_vals,   y = 10 + 80 * t_vals )  # Assign sandy loam compositions with measurement variation obs_comps <- list() for (i in 1:nrow(obs_coords)) {   base_comp <- c(SAND = 55, SILT = 30, CLAY = 15)   noise <- rnorm(3, mean = 0, sd = 2)   obs_comp <- pmax(pmin(base_comp + noise, 100), 0)   obs_comp <- obs_comp / sum(obs_comp) * 100   obs_comps[[i]] <- obs_comp } obs_samples <- as.data.frame(do.call(rbind, obs_comps))  # Transform to ILR space obs_ilr <- compositions::ilr(compositions::acomp(obs_samples)) colnames(obs_ilr) <- c(\"ilr1\", \"ilr2\")  comparison_data <- sf::st_as_sf(   data.frame(x = obs_coords$x, y = obs_coords$y, obs_ilr),   coords = c(\"x\", \"y\") ) # Univariate model with conditioning data model_univ_cond <- gc_ilr_model(   params,    variogram_model = vgm_model,   data = comparison_data )  # LMC model with conditioning data model_lmc_cond <- gc_ilr_model(   params,    variogram_model = vgm_model,   data = comparison_data,   model_type = \"lmc\" ) fine_grid <- expand.grid(   x = seq(0, 100, by = 5),   y = seq(0, 100, by = 5) ) fine_grid_sf <- sf::st_as_sf(fine_grid, coords = c(\"x\", \"y\")) sims_univ_comp <- gc_sim_composition(   model_univ_cond, fine_grid_sf, nsim = 1,   target_names = c(\"sand\", \"silt\", \"clay\") )  sims_lmc_comp <- gc_sim_composition(   model_lmc_cond, fine_grid_sf, nsim = 1,   target_names = c(\"sand\", \"silt\", \"clay\") ) par(mfrow = c(1, 2))  plot(sims_univ_comp[[\"sand.sim1\"]], main = \"Univariate: Sand\", zlim = c(30, 75)) cond_coords <- sf::st_coordinates(comparison_data) points(cond_coords[, 1], cond_coords[, 2], pch = 1, cex = 2, col = \"black\", lwd = 2)  plot(sims_lmc_comp[[\"sand.sim1\"]], main = \"LMC: Sand\", zlim = c(30, 75)) points(cond_coords[, 1], cond_coords[, 2], pch = 1, cex = 2, col = \"black\", lwd = 2) par(mfrow = c(1, 1)) # Extract predicted values at observation points univ_extracted <- terra::extract(sims_univ_comp, comparison_data) lmc_extracted <- terra::extract(sims_lmc_comp, comparison_data)  # Compare to observed values comparison_table <- data.frame(   Observed = obs_samples$SAND,   Univariate = univ_extracted$sand.sim1,   LMC = lmc_extracted$sand.sim1,   Univ_Error = abs(univ_extracted$sand.sim1 - obs_samples$SAND),   LMC_Error = abs(lmc_extracted$sand.sim1 - obs_samples$SAND) )  comparison_table #>    Observed Univariate      LMC   Univ_Error    LMC_Error #> 1  52.23030   52.23030 52.23030 1.421085e-14 0.000000e+00 #> 2  54.88676   50.69617 61.24788 4.190586e+00 6.361118e+00 #> 3  54.26647   55.14599 53.15188 8.795135e-01 1.114598e+00 #> 4  55.07955   57.19096 56.84773 2.111406e+00 1.768171e+00 #> 5  55.64003   44.72407 59.25459 1.091597e+01 3.614557e+00 #> 6  54.45975   52.54057 57.05396 1.919183e+00 2.594207e+00 #> 7  55.82712   54.71037 46.46575 1.116746e+00 9.361366e+00 #> 8  54.78208   58.29805 58.46982 3.515965e+00 3.687736e+00 #> 9  54.23885   50.77341 53.17414 3.465442e+00 1.064710e+00 #> 10 54.27075   54.27075 54.27075 0.000000e+00 7.105427e-15"},{"path":[]},{"path":"/articles/soil_texture_workflow.html","id":"evaluating-data-quality-stationarity-and-gaussianity","dir":"Articles","previous_headings":"Quality Assessment and Remediation","what":"Evaluating Data Quality: Stationarity and Gaussianity","title":"Soil Texture Workflow","text":"proceeding spatial simulation, assess whether data meets assumptions required geostatistical methods. Two key assessments inform remediation strategy: Stationarity: Whether statistical properties vary across study area Gaussianity: Whether ILR-transformed data multivariate normal Based results assessments, can select appropriate remediation techniques. Prepare sample data ILR values diagnostics:","code":"# Create sample data with spatial coordinates set.seed(123) n_samples <- 100 sample_locations_with_ilr <- data.frame(   x = runif(n_samples, 0, 100),   y = runif(n_samples, 0, 100),   ilr1 = rnorm(n_samples, mean = 0.5, sd = 0.8),   ilr2 = rnorm(n_samples, mean = -0.2, sd = 0.6) )  head(sample_locations_with_ilr) #>          x        y        ilr1       ilr2 #> 1 28.75775 59.99890 -0.06832525  1.1192862 #> 2 78.83051 33.28235  0.70550697  0.5874478 #> 3 40.89769 48.86130  0.30264650 -0.3590870 #> 4 88.30174 95.44738  0.22196592  0.1259164 #> 5 94.04673 48.29024 -0.26129485 -0.4486040 #> 6  4.55565 89.03502  0.46397782 -0.4857481"},{"path":"/articles/soil_texture_workflow.html","id":"assessing-stationarity","dir":"Articles","previous_headings":"Quality Assessment and Remediation > Evaluating Data Quality: Stationarity and Gaussianity","what":"Assessing Stationarity","title":"Soil Texture Workflow","text":"Spatial stationarity means covariance structure constant across domain. Non-stationarity suggests domain contains distinct compositional provinces modeled separately. gc_assess_stationarity() function uses PCA biplot visualization detect spatial clustering data points:  biplot colors points X-coordinate. points cluster spatial location (e.g., left side vs right side direction), indicates non-stationarity suggests domain stratification. Interpretation: Stationary: Points scattered randomly biplot without spatial clustering. Proceed global LMC modeling. Non-stationary: Points cluster spatially. Either stratify domain apply domain-specific models stratum. alternative quantitative approach divides domain windows: local method compares covariance structures within windows. Large variation windows indicates non-stationarity supports domain stratification.","code":"stationarity_result <- gc_assess_stationarity(   sample_locations_with_ilr,   method = \"biplot\",   plot = TRUE ) stationarity_local <- gc_assess_stationarity(   sample_locations_with_ilr,   method = \"local\",   plot = FALSE )  stationarity_local$summary #>          Method WindowsAnalyzed NormalizedCovDiff Stationary #> 1 Local Windows              12            0.6876      FALSE #>                                                                                                          Interpretation #> 1 Potential non-stationarity detected: Local covariances vary substantially (0.688). Domain stratification recommended."},{"path":"/articles/soil_texture_workflow.html","id":"assessing-gaussianity","dir":"Articles","previous_headings":"Quality Assessment and Remediation > Evaluating Data Quality: Stationarity and Gaussianity","what":"Assessing Gaussianity","title":"Soil Texture Workflow","text":"Sequential Gaussian Simulation assumes ILR-transformed data multivariate normal. gc_assess_gaussianity() function tests assumption:  Available Methods: Anderson-Darling (recommended): Tests ILR dimension separately. Sensitive tail departures normality. Shapiro-Wilk: Alternative univariate test, limited N ≤ 5000 samples. Mardia: Multivariate test joint skewness kurtosis, provides holistic assessment. Interpretation: Gaussian (p-value > 0.05): Proceed Sequential Gaussian Simulation (SGS). Apply anamorphosis (normal-score back-transform simulation) Stratify domain geological soil units Document accept uncertainty simulation","code":"ilr_values <- sample_locations_with_ilr[, c(\"ilr1\", \"ilr2\")]  gaussianity_result <- gc_assess_gaussianity(   ilr_values,   method = \"anderson\",   plot = TRUE,   alpha = 0.05 ) gaussianity_result$recommendation #> [1] \"Non-Gaussianity detected in dimension(s) 2. Recommend anamorphosis (normal-score transform) or domain stratification.\""},{"path":"/articles/soil_texture_workflow.html","id":"applying-anamorphosis-remediation","dir":"Articles","previous_headings":"Quality Assessment and Remediation > Evaluating Data Quality: Stationarity and Gaussianity","what":"Applying Anamorphosis Remediation","title":"Soil Texture Workflow","text":"data non-Gaussian, anamorphosis transforms simulated values normal space back original data distribution preserving spatial correlation. works matching quantiles simulated data quantiles reference data. anamorphosis process: Computes quantiles reference (original) ILR values Computes quantiles simulated values Maps simulated quantiles reference quantiles (inverse transform) Interpolates values quantiles Optionally despiking cap extreme extrapolations preserves marginal distribution original data maintaining spatial correlation structure simulation.","code":"ilr_values <- sample_locations_with_ilr[, c(\"ilr1\", \"ilr2\")]  sim_ilr <- matrix(rnorm(100, 0, 1), nrow = 50, ncol = 2) colnames(sim_ilr) <- c(\"ilr1\", \"ilr2\")  back_transformed <- gc_apply_anamorphosis(   sim_ilr,   ref_ilr_values = ilr_values,   despike = TRUE )  ref_range <- apply(ilr_values, 2, range) all(back_transformed >= ref_range[1, ] & back_transformed <= ref_range[2, ]) #> [1] FALSE"},{"path":"/articles/soil_texture_workflow.html","id":"identifying-domain-strata","dir":"Articles","previous_headings":"Quality Assessment and Remediation > Evaluating Data Quality: Stationarity and Gaussianity","what":"Identifying Domain Strata","title":"Soil Texture Workflow","text":"non-stationarity detected, domain may contain distinct compositional provinces geological units modeled separately. gc_identify_strata() function partitions observations spatially-coherent strata using clustering methods.  stratification identifies: Strata PCA space: Shows clusters separate observations based compositional variance. PCA reduces dimensionality retaining structure distinguishes domains. Strata spatial layout: Reveals whether clusters geographically coherent. Tight, localized clusters indicate true domain partitioning, scattered patterns may suggest mixed lithologies contamination. Quality metrics: Silhouette widths measure well observation fits assigned stratum (ranges -1 1, >0.5 indicates good separation). Average silhouette widths stratum guide model selection. strata identified, can model stratum independently:","code":"# Identify strata using K-means clustering in PCA space strata_result <- gc_identify_strata(   sample_locations_with_ilr,   n_strata = 2,   method = \"kmeans\",   plot = TRUE ) # Examine the stratification results strata_result$n_strata #> [1] 2 table(strata_result$strata) #>  #>  1  2  #> 65 35 # Model first stratum stratum_1_data <- sample_locations_with_ilr[strata_result$strata == 1, ] stratum_2_data <- sample_locations_with_ilr[strata_result$strata == 2, ]  # Each stratum can now be assessed for stationarity and Gaussianity stat_1 <- gc_assess_stationarity(stratum_1_data, method = \"biplot\", plot = FALSE) stat_2 <- gc_assess_stationarity(stratum_2_data, method = \"biplot\", plot = FALSE)  # Proceed with workflow on each stratum independently"},{"path":"/articles/soil_texture_workflow.html","id":"integrated-diagnostic-workflow","dir":"Articles","previous_headings":"Quality Assessment and Remediation > Evaluating Data Quality: Stationarity and Gaussianity","what":"Integrated Diagnostic Workflow","title":"Soil Texture Workflow","text":"complete assessment combines stationarity Gaussianity tests determine appropriate remediation strategy. Run diagnostics data: results determine remediation path: Stationary + Gaussian: Proceed standard workflow (LMC modeling Sequential Gaussian Simulation) Non-stationary + Gaussian: Stratify domain using gc_identify_strata(), apply workflow stratum Stationary + Non-Gaussian: Apply anamorphosis simulated results gc_apply_anamorphosis() Non-stationary + Non-Gaussian: Stratify domain apply anamorphosis stratum’s simulated results gc_identify_strata() function can automatically partition domain based PCA clustering non-stationarity detected, suggesting split data independent modeling.","code":"stat_result <- gc_assess_stationarity(   sample_locations_with_ilr,   method = \"biplot\",   plot = FALSE )  ilr_vals <- sample_locations_with_ilr[, c(\"ilr1\", \"ilr2\")] gauss_result <- gc_assess_gaussianity(   ilr_vals,   method = \"anderson\",   plot = FALSE )  assessment <- data.frame(   Aspect = c(\"Stationarity\", \"Gaussianity\"),   Status = c(     if (stat_result$stationary) \"Yes\" else \"No\",     if (gauss_result$gaussian) \"Yes\" else \"No\"   ) ) assessment #>         Aspect Status #> 1 Stationarity    Yes #> 2  Gaussianity     No"},{"path":"/articles/soil_texture_workflow.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Soil Texture Workflow","text":"Aitchison, J. (1986). Statistical Analysis Compositional Data. Egozcue et al. (2003). Isometric logratio transformations compositional data analysis. Chilès, J.P. & Delfiner, P. (2012). Geostatistics: Modeling Spatial Uncertainty.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Andrew Brown. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Brown (2026). geocoda: Spatial Simulation Compositional Data. R package version 0.1.0.","code":"@Manual{,   title = {geocoda: Spatial Simulation of Compositional Data},   author = {Andrew Brown},   year = {2026},   note = {R package version 0.1.0}, }"},{"path":[]},{"path":"/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Spatial Simulation of Compositional Data","text":"geocoda R package geostatistical simulation compositional data. implements complete workflow generating spatial realizations constrained multivariate compositions using Isometric Log-Ratio (ILR) transformations geostatistical kriging (Independent Univariate Linear Model Coregionalization). designed handle compositional data (geochemistry, vegetation proportions, etc.), primary application spatial simulation soil texture separates (sand, silt, clay) - proportions sum constant (typically 100%).","code":""},{"path":"/index.html","id":"workflow","dir":"","previous_headings":"","what":"Workflow","title":"Spatial Simulation of Compositional Data","text":"package follows five-step process: Constrain - Define validity bounds component (low, representative, high) Transform - Convert compositions Isometric Log-Ratio (ILR) space break sum constraint Model - Fit multivariate geostatistical model ILR variables (univariate LMC) Simulate - Generate spatial realizations ILR space Back-transform - Return original units, guaranteeing sum constraint","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Spatial Simulation of Compositional Data","text":"","code":"# Install from GitHub  remotes::install_github(\"brownag/geocoda\")"},{"path":"/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"Spatial Simulation of Compositional Data","text":"","code":"library(geocoda)  # Define composition bounds (Sand, Silt, Clay percentages) constraints <- list(   SAND = list(min = 0, max = 40),   SILT = list(min = 50, max = 80),   CLAY = list(min = 10, max = 20) )  # Expand into a valid composition grid grid <- expand_compositional_bounds(constraints, step = 0.5, target_sum = 100)  # Bootstrap samples from valid compositions set.seed(123) samples <- bootstrap_compositional_samples(grid, n = 1000, method = \"uniform\")  # Estimate ILR parameters from samples params <- estimate_ilr_params(samples)  # Build a variogram model (user-specified) library(gstat) vgm_template <- vgm(psill = 1, model = \"Exp\", range = 30, nugget = 0.01)  # Construct the multivariate gstat model model <- build_compositional_model(params, variogram_model = vgm_template)  # Create a spatial grid x.range <- seq(0, 100, by = 5) y.range <- seq(0, 100, by = 5) grid_sf <- sf::st_as_sf(   expand.grid(x = x.range, y = y.range),   coords = c(\"x\", \"y\"),   crs = \"local\" )  # Simulate 10 realizations sims <- sim_compositional_field(model, grid_sf, nsim = 10)  # Result is a SpatRaster with layers: # sand.sim1, silt.sim1, clay.sim1, sand.sim2, silt.sim2, clay.sim2, ... print(sims)"},{"path":"/index.html","id":"key-functions","dir":"","previous_headings":"","what":"Key Functions","title":"Spatial Simulation of Compositional Data","text":"expand_compositional_bounds() - Generate grid valid compositions constraints bootstrap_compositional_samples() - Draw samples valid compositions (uniform soil texture) estimate_ilr_params() - Calculate ILR mean covariance gc_ilr_model() - Construct multivariate gstat model Independent Univariate kriging (default) LMC; supports conditional simulation gc_vgm_defaults() - Suggest reasonable variogram parameters based data gc_fit_vgm() - Fit empirical variograms per ILR dimension optional aggregation gc_sim_composition() - Simulate back-transform original units; supports conditioning observed data","code":""},{"path":[]},{"path":"/index.html","id":"id_2-model-types-univariate-vs-lmc","dir":"","previous_headings":"Advanced Features","what":"2. Model Types: Univariate vs LMC","title":"Spatial Simulation of Compositional Data","text":"gc_ilr_model() function supports two modeling approaches via model_type parameter: Independent Univariate Kriging (model_type = \"univariate\", default): - Models ILR dimension separately without cross-covariance terms - Numerically stable robust (avoids positive-definite issues) - Standard practice compositional geostatistics - Efficient large problems - Recommended applications Linear Model Coregionalization (model_type = \"lmc\"): - Includes cross-covariance terms pairs ILR dimensions - Theoretically complete - numerically complex - Useful cross-correlation structure important","code":"# Univariate (default, recommended) model_univ <- gc_ilr_model(params, variogram_model = vgm_template)  # LMC (alternative with cross-covariance terms) model_lmc <- gc_ilr_model(params, variogram_model = vgm_template, model_type = \"lmc\")  # Both produce equivalent results for most practical applications, # but univariate is faster and more numerically stable"},{"path":"/index.html","id":"id_3-conditional-simulation","dir":"","previous_headings":"Advanced Features","what":"3. Conditional Simulation","title":"Spatial Simulation of Compositional Data","text":"gc_ilr_model() gc_sim_composition() functions support conditioning observed data: Key properties: - Unconditional (default): Independent realizations spatial distribution - Conditional: Realizations honor observed values exactly sample locations - Uncertainty reduction: Away sample locations, uncertainty decreases distance - Maintains sum constraint cases","code":"# Create conditioning data in ILR space obs_ilr <- compositions::ilr(compositions::acomp(observed_samples)) colnames(obs_ilr) <- c(\"ilr1\", \"ilr2\", \"ilr3\") conditioning_data <- sf::st_as_sf(   cbind(obs_locations, as.data.frame(obs_ilr)),   coords = c(\"x\", \"y\"),   crs = \"local\" )  # Build model with conditioning data model_cond <- gc_ilr_model(   params,    variogram_model = vgm_template,   data = conditioning_data  # Pass observed data for kriging )  # Simulate with conditioning sims_cond <- gc_sim_composition(   model_cond,    grid_sf,    nsim = 10,   observed_data = conditioning_data )"},{"path":"/index.html","id":"id_4-empirical-variogram-fitting","dir":"","previous_headings":"Advanced Features","what":"4. Empirical Variogram Fitting","title":"Spatial Simulation of Compositional Data","text":"gc_fit_vgm() function automatically fits empirical variograms ILR dimension: Key advantages: - Captures spatial structure unique component - Covariance-weighted aggregation ensures high-variance dimensions contribute appropriately - Returns per-dimension fitted models detailed inspection","code":"# Fit variograms to ILR values at observed locations data_with_ilr <- data.frame(   x = sample_locations$x,   y = sample_locations$y,   ilr1 = ilr_values[, 1],   ilr2 = ilr_values[, 2],   ilr3 = ilr_values[, 3] )  # Per-dimension results fitted_per_dim <- gc_fit_vgm(   params,    data = data_with_ilr,   aggregate = FALSE )  # Or get aggregated template for model building fitted_template <- gc_fit_vgm(   params,   data = data_with_ilr,   aggregate = TRUE )  model <- gc_ilr_model(params, variogram_model = fitted_template)"},{"path":"/index.html","id":"id_3-vignette--soil-texture-workflow","dir":"","previous_headings":"Advanced Features","what":"3. Vignette & Soil Texture Workflow","title":"Spatial Simulation of Compositional Data","text":"comprehensive workflow vignette demonstrates complete soil texture simulation: vignette covers: - Soil texture constraints (USDA triangle) - Bootstrap sampling realistic compositions - ILR parameter estimation - Variogram fitting optimization - Grid creation simulation - Validation (sum constraints, range checks) - Visualization results - Tips troubleshooting","code":"vignette(\"soil_texture_workflow\", package = \"geocoda\")"},{"path":"/index.html","id":"dependencies","dir":"","previous_headings":"","what":"Dependencies","title":"Spatial Simulation of Compositional Data","text":"Imports: - compositions - ILR transformations - gstat - Geostatistical modeling simulation - terra - Raster data handling - sf - Spatial feature support Suggests: - aqp - Soil texture bootstrapping utilities - testthat - Unit testing - knitr - Documentation","code":""},{"path":"/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Spatial Simulation of Compositional Data","text":"MIT","code":""},{"path":"/index.html","id":"author","dir":"","previous_headings":"","what":"Author","title":"Spatial Simulation of Compositional Data","text":"Andrew G. Brown","code":""},{"path":"/reference/gc_expand_bounds.html","id":null,"dir":"Reference","previous_headings":"","what":"Expand Compositional Bounds into a Valid Grid — gc_expand_bounds","title":"Expand Compositional Bounds into a Valid Grid — gc_expand_bounds","text":"Generate grid valid compositions component constraints. Uses expand.grid() create combinations sequential component values within specified bounds, filters rows component sums equal target sum (within floating-point tolerance).","code":""},{"path":"/reference/gc_expand_bounds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expand Compositional Bounds into a Valid Grid — gc_expand_bounds","text":"","code":"gc_expand_bounds(constraints, step = 0.1, target_sum = 100, tol = 1e-06)"},{"path":"/reference/gc_expand_bounds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expand Compositional Bounds into a Valid Grid — gc_expand_bounds","text":"constraints named list lists data frame containing min max component. Example: list(SAND = list(min = 0, max = 40), SILT = list(min = 50, max = 80), CLAY = list(min = 10, max = 20)). step Numeric resolution grid sequences (default 0.1). target_sum Numeric constant sum valid compositions (default 100). tol Floating-point tolerance sum constraint (default 1e-6).","code":""},{"path":"/reference/gc_expand_bounds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expand Compositional Bounds into a Valid Grid — gc_expand_bounds","text":"data frame columns components rows valid compositions summing target_sum.","code":""},{"path":"/reference/gc_expand_bounds.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Expand Compositional Bounds into a Valid Grid — gc_expand_bounds","text":"function performs: Validation min values sum target_sum Dynamic sequence generation component based bounds Cartesian product expansion via expand.grid() Filtering compositions sum approximately equal target_sum","code":""},{"path":"/reference/gc_expand_bounds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Expand Compositional Bounds into a Valid Grid — gc_expand_bounds","text":"","code":"# Define sand, silt, clay bounds constraints <- list(   SAND = list(min = 0, max = 40),   SILT = list(min = 50, max = 80),   CLAY = list(min = 10, max = 20) )  # Expand with 1% resolution grid <- gc_expand_bounds(constraints, step = 1.0, target_sum = 100) nrow(grid) #> [1] 341 head(grid) #>   SAND SILT CLAY #> 1   40   50   10 #> 2   39   51   10 #> 3   38   52   10 #> 4   37   53   10 #> 5   36   54   10 #> 6   35   55   10"},{"path":"/reference/gc_fit_vgm.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimize Variogram Parameters — gc_fit_vgm","title":"Optimize Variogram Parameters — gc_fit_vgm","text":"Fit empirical variograms ILR values observed locations estimate optimal variogram parameters ILR dimension. Results can returned per-dimension aggregated single template variogram use multivariate simulation. Includes diagnostics LMC admissibility.","code":""},{"path":"/reference/gc_fit_vgm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimize Variogram Parameters — gc_fit_vgm","text":"","code":"gc_fit_vgm(   ilr_params,   data,   vgm_model_type = \"Exp\",   maxdist = NULL,   width = NULL,   aggregate = FALSE,   correct.diagonal = 1.01,   fit.ranges = FALSE )"},{"path":"/reference/gc_fit_vgm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimize Variogram Parameters — gc_fit_vgm","text":"ilr_params list returned gc_ilr_params(). data data frame spatial object (sf) columns x, y spatial coordinates columns named ilr1, ilr2, etc., containing ILR values observed locations. vgm_model_type Character string specifying variogram model type (e.g., \"Exp\", \"Sph\", \"Gau\"). Default \"Exp\". maxdist Maximum distance empirical variogram calculation (default NULL, uses pairs). width Lag width empirical variogram bins (default NULL, automatic). aggregate Logical. TRUE, aggregate fitted parameters across ILR dimensions using weighted average sills (weights = covariance diagonal). FALSE (default), return per-dimension results. correct.diagonal Numeric sill correction factor LMC stability (default 1.01). Multiplies marginal (diagonal) sill factor improve positive-definiteness LMC sill matrix prevent numerical issues. Recommended range: 1.00-1.05. Use 1.01 typical applications. fit.ranges Logical. FALSE (default), fixes ranges fitted values LMC construction avoid -parameterization. TRUE, allows range re-optimization building LMC models.","code":""},{"path":"/reference/gc_fit_vgm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimize Variogram Parameters — gc_fit_vgm","text":"list : aggregate = FALSE: list length D-1 element contains fitted_vgm empirical_vgm ILR dimension. aggregate = TRUE: single vgm object aggregated parameters (mean range, weighted mean sill, weighted mean nugget). Attribute ilr_dimension_names: Names ILR dimensions (ilr1, ilr2, ...) Attribute fitted_params: Data frame per-dimension parameters Attribute lmc_admissibility: Logical indicating sill matrix positive-definite","code":""},{"path":"/reference/gc_fit_vgm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Optimize Variogram Parameters — gc_fit_vgm","text":"function: ILR dimension : Computes empirical variogram using gstat::variogram() Provides intelligent initial model (range ~ spatial extent / 3) Fits parametric model using gstat::fit.variogram() Optionally aggregates results using covariance-weighted averaging Applies correct.diagonal diagonal sills ensure LMC positive-definiteness Weighted aggregation combines results building single LMC model, ensuring dimensions higher variance contribute proportionally. LMC Admissibility: sill matrix (covariance distance infinity) must positive-definite valid spatial covariance. eigenvalues sill matrix zero negative values, LMC structure inadmissible. correct.diagonal parameter helps stabilize sill matrix inflating diagonal terms, typically improves admissibility without distorting model significantly.","code":""},{"path":"/reference/gc_fit_vgm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Optimize Variogram Parameters — gc_fit_vgm","text":"","code":"if (FALSE) { # \\dontrun{ # Example with observed ILR values on a spatial grid library(gstat)  # Create sample data with spatial coordinates and ILR values n_points <- 50 coords_df <- data.frame(   x = runif(n_points, 0, 100),   y = runif(n_points, 0, 100),   ilr1 = rnorm(n_points, mean = 0.5, sd = 0.8),   ilr2 = rnorm(n_points, mean = -0.2, sd = 0.6) )  # Estimate parameters from bootstrap samples samples <- data.frame(   sand = c(20, 25, 30, 22),   silt = c(60, 55, 50, 58),   clay = c(20, 20, 20, 20) ) params <- gc_ilr_params(samples)  # Fit empirical variograms fitted <- gc_fit_vgm(   params,   coords_df,   vgm_model_type = \"Exp\",   aggregate = FALSE )  # Or get single aggregated template fitted_agg <- gc_fit_vgm(   params,   coords_df,   vgm_model_type = \"Exp\",   aggregate = TRUE ) } # }"},{"path":"/reference/gc_handle_zeros.html","id":null,"dir":"Reference","previous_headings":"","what":"Handle Zeros and Censored Data in Compositional Data — gc_handle_zeros","title":"Handle Zeros and Censored Data in Compositional Data — gc_handle_zeros","text":"Process compositional data containing zeros -detection-limit (censored) values using log-ratio imputation. Imputation critical compositional data analysis geometric mean zeros undefined, making standard covariance analysis unstable. function provides three strategies: multiplicative zero imputation, additive zero imputation, probabilistic imputation using EM algorithm.","code":""},{"path":"/reference/gc_handle_zeros.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Handle Zeros and Censored Data in Compositional Data — gc_handle_zeros","text":"","code":"gc_handle_zeros(comp_data, method = \"mzero\", dl = NULL, tolerance = 1e-10)"},{"path":"/reference/gc_handle_zeros.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Handle Zeros and Censored Data in Compositional Data — gc_handle_zeros","text":"comp_data data frame columns representing compositional parts (e.g., sand, silt, clay). Rows least one zero negative value candidates imputation. method Character string specifying imputation approach: \"mzero\" (default): Multiplicative zero imputation using zCompositions::multLRM() \"azero\": Additive zero imputation using zCompositions::addLRM() \"lrem\": Log-ratio expectation-maximization using zCompositions::lrEM() Recommended: Use \"lrem\" data many zeros; use \"mzero\" sparse zeros. log-ratio based preserve compositional geometry. dl Numeric vector detection limits (one per column) handling censored data. Default NULL treats positive values observed. provided, values dl[] treated left-censored column . used method = \"lrem\". tolerance Numeric tolerance identifying zeros (default 1e-10). Values absolute value threshold treated zeros.","code":""},{"path":"/reference/gc_handle_zeros.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Handle Zeros and Censored Data in Compositional Data — gc_handle_zeros","text":"list containing: imputed_data: Data frame imputed compositional values n_zeros_imputed: Integer count zero/censored values imputed imputation_rate: Proportion values imputed (n_zeros / total_values) method_used: Character string imputation method name row_status: Factor indicating rows modified: \"observed\": imputation needed (zeros/negative values) \"imputed\": least one zero/censored value replaced \"failed\": Imputation failed (row excluded analysis)","code":""},{"path":"/reference/gc_handle_zeros.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Handle Zeros and Censored Data in Compositional Data — gc_handle_zeros","text":"Zero Imputation Strategies: Multiplicative Zero Replacement (mzero): Replaces zeros small multiple detection limit, applies log-ratio closure. Fast, appropriate isolated zeros. Additive Zero Replacement (azero): Adds small constant values closure. Conservative robust, can distort low-abundance components. Log-Ratio EM (lrem): Probabilistic imputation using expectation-maximization log-ratio transformed data. Respects compositional geometry honoring censoring patterns. theoretically sound slower replacement methods. Detection Limits: dl provided method = \"lrem\", values detection limit treated left-censored (uncertainty exact value). EM iterates estimate likely imputed values consistent censoring pattern covariance structure.","code":""},{"path":"/reference/gc_handle_zeros.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Handle Zeros and Censored Data in Compositional Data — gc_handle_zeros","text":"","code":"if (FALSE) { # \\dontrun{ # Example: Soil texture data with some zeros or missing detections soil_samples <- data.frame(   sand = c(40, 35, 0, 42, 38),   silt = c(35, 40, 45, 36, 40),   clay = c(25, 25, 55, 22, 22) )  # Check for zeros before imputation has_zeros <- rowSums(soil_samples == 0) > 0 print(paste(\"Rows with zeros:\", sum(has_zeros)))  # Impute using multiplicative zero replacement result_mzero <- gc_handle_zeros(soil_samples, method = \"mzero\") print(result_mzero$imputed_data) print(paste(\"Imputation rate:\", result_mzero$imputation_rate))  # Impute using log-ratio EM (more principled) result_lrem <- gc_handle_zeros(soil_samples, method = \"lrem\") print(result_lrem$imputed_data)  # With detection limits (censored measurements) detection_limits <- c(sand = 1, silt = 1, clay = 1) result_dl <- gc_handle_zeros(soil_samples, method = \"lrem\", dl = detection_limits) } # }"},{"path":"/reference/gc_ilr_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Build Compositional Geostatistical Model — gc_ilr_model","title":"Build Compositional Geostatistical Model — gc_ilr_model","text":"Constructs gstat model ILR-transformed variables using either Independent Univariate Kriging Linear Model Coregionalization (LMC).","code":""},{"path":"/reference/gc_ilr_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build Compositional Geostatistical Model — gc_ilr_model","text":"","code":"gc_ilr_model(   ilr_params,   variogram_model,   data = NULL,   model_type = \"univariate\" )"},{"path":"/reference/gc_ilr_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build Compositional Geostatistical Model — gc_ilr_model","text":"ilr_params list gc_ilr_params() containing mean, cov, names. variogram_model vgm() object defining base variogram structure. data Optional sf object ILR columns conditioning. provided, Conditional Simulation performed. NULL (default), Unconditional Simulation performed. model_type Character string specifying approach: \"univariate\" (default) \"lmc\". Univariate numerically stable standard practice. LMC includes cross-covariance terms ILR dimensions.","code":""},{"path":"/reference/gc_ilr_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build Compositional Geostatistical Model — gc_ilr_model","text":"gstat object representing model.","code":""},{"path":"/reference/gc_ilr_model.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Build Compositional Geostatistical Model — gc_ilr_model","text":"Independent Univariate Kriging (model_type = \"univariate\"): Models ILR dimension separately without cross-covariance terms. : Numerically stable (avoids positive-definite issues LMC fitting) Standard practice compositional geostatistics Robust across different datasets Efficient large problems ILR transformation already decorrelates data significantly, ignoring spatial cross-correlation ILR coordinates minimal impact. Linear Model Coregionalization (model_type = \"lmc\"): Includes cross-covariance terms pairs ILR dimensions. : Theoretically complete numerically complex Useful cross-correlation structure important conditional simulation, conditioning data must passed function (predict()). model automatically uses data prediction.","code":""},{"path":"/reference/gc_ilr_params.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate ILR Parameters from Compositional Samples — gc_ilr_params","title":"Estimate ILR Parameters from Compositional Samples — gc_ilr_params","text":"Convert compositional samples Isometric Log-Ratio (ILR) space compute mean vector covariance matrix. statistics used parameterize multivariate geostatistical model.","code":""},{"path":"/reference/gc_ilr_params.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate ILR Parameters from Compositional Samples — gc_ilr_params","text":"","code":"gc_ilr_params(samples)"},{"path":"/reference/gc_ilr_params.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate ILR Parameters from Compositional Samples — gc_ilr_params","text":"samples data frame compositions (row sums constant, typically 100% 1).","code":""},{"path":"/reference/gc_ilr_params.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate ILR Parameters from Compositional Samples — gc_ilr_params","text":"list containing: mean: Vector ILR means (length D-1 D number components) cov: Covariance matrix ILR values (dimensions (D-1) x (D-1)) names: Original component names (character vector) base_class: Class used transformation (\"acomp\")","code":""},{"path":"/reference/gc_ilr_params.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate ILR Parameters from Compositional Samples — gc_ilr_params","text":"function: Stores original column names later use Converts compositions::acomp (absolute composition) Applies compositions::ilr transformation Computes column means covariance matrix ILR values ILR transformation eliminates sum constraint, allowing standard multivariate geostatistics applied.","code":""},{"path":"/reference/gc_ilr_params.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate ILR Parameters from Compositional Samples — gc_ilr_params","text":"","code":"# Simulate some simple compositions samples <- data.frame(   sand = c(20, 25, 30, 22),   silt = c(60, 55, 50, 58),   clay = c(20, 20, 20, 20) )  params <- estimate_ilr_params(samples) #> Error in estimate_ilr_params(samples): could not find function \"estimate_ilr_params\" str(params) #> Error: object 'params' not found print(params$mean) #> Error: object 'params' not found print(params$cov) #> Error: object 'params' not found"},{"path":"/reference/gc_resample_compositions.html","id":null,"dir":"Reference","previous_headings":"","what":"Bootstrap Compositional Samples — gc_resample_compositions","title":"Bootstrap Compositional Samples — gc_resample_compositions","text":"Draw samples valid composition grid create \"source population\" estimating covariance structure ILR space. Supports uniform random sampling soil texture-aware bootstrapping (aqp available).","code":""},{"path":"/reference/gc_resample_compositions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bootstrap Compositional Samples — gc_resample_compositions","text":"","code":"gc_resample_compositions(   composition_grid,   n = 1000,   method = \"uniform\",   seed = NULL )"},{"path":"/reference/gc_resample_compositions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bootstrap Compositional Samples — gc_resample_compositions","text":"composition_grid data frame valid compositions (typically output gc_expand_bounds()). n Number samples draw (default 1000). method Sampling method: \"uniform\" (simple random sampling) \"soil_texture\" (uses aqp::bootstrapSoilTexture() available, falls back uniform ). seed Optional random seed reproducibility.","code":""},{"path":"/reference/gc_resample_compositions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bootstrap Compositional Samples — gc_resample_compositions","text":"list : samples: data frame sampled compositions. method: method used. n: Number samples requested.","code":""},{"path":"/reference/gc_resample_compositions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bootstrap Compositional Samples — gc_resample_compositions","text":"Uniform sampling: Performs simple random sampling row indices without replacement. n > nrow(composition_grid), samples replacement. Soil texture sampling: Attempts delegate aqp::bootstrapSoilTexture(). aqp installed, falls back uniform sampling warning.","code":""},{"path":"/reference/gc_resample_compositions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bootstrap Compositional Samples — gc_resample_compositions","text":"","code":"# Create a simple composition grid constraints <- list(   SAND = list(min = 0, max = 40),   SILT = list(min = 50, max = 80),   CLAY = list(min = 10, max = 20) ) grid <- gc_expand_bounds(constraints, step = 1.0, target_sum = 100)  # Uniform sampling set.seed(42) uniform_samps <- gc_resample_compositions(grid, n = 100, method = \"uniform\") nrow(uniform_samps$samples) #> [1] 100"},{"path":"/reference/gc_sim_composition.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate and Back-Transform Compositional Fields — gc_sim_composition","title":"Simulate and Back-Transform Compositional Fields — gc_sim_composition","text":"Generate spatial realizations compositional data predicting ILR space using gstat model, back-transforming original units. Supports unconditional simulation (independent data) conditional simulation (honoring observed values sample locations). Multiple realizations stacked multi-layer terra::SpatRaster.","code":""},{"path":"/reference/gc_sim_composition.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate and Back-Transform Compositional Fields — gc_sim_composition","text":"","code":"gc_sim_composition(   model,   locations,   nsim = 1,   target_names = NULL,   crs = \"local\",   observed_data = NULL,   nmax = NULL )"},{"path":"/reference/gc_sim_composition.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate and Back-Transform Compositional Fields — gc_sim_composition","text":"model gstat object (typically gc_ilr_model()). conditional simulation, model must built data parameter conditioning data embedded model. locations sf object data frame defining simulation grid. Must contain x y columns. data frame provided, converted sf object coordinates specified CRS. nsim Number realizations (default 1). target_names Character vector original component names. NULL, inferred gstat model defaults c(\"comp1\", \"comp2\", ...). crs Coordinate reference system (default \"local\"). observed_data optional sf object data frame containing observed compositional samples conditional simulation. Must structure data used build model: columns x, y coordinates, columns ILR dimension named ilr1, ilr2, etc. (ILR space). NULL (default), unconditional simulation performed. nmax Maximum number nearby observations use prediction location (default NULL, uses observations). Setting smaller nmax (e.g., 12-15) can: Improve computational efficiency large datasets Reduce memory usage prediction Create local uncertainty estimates (Screen Effect) May introduce slight artifacts spatial boundaries Recommended: Use NULL small/medium datasets, nmax=12-20 large datasets.","code":""},{"path":"/reference/gc_sim_composition.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate and Back-Transform Compositional Fields — gc_sim_composition","text":"terra::SpatRaster layers named according pattern: <component>.sim<N> component target_names sim<N> indicates realization number. example, 3 components 2 realizations: comp1.sim1, comp2.sim1, comp3.sim1, comp1.sim2, ...","code":""},{"path":"/reference/gc_sim_composition.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate and Back-Transform Compositional Fields — gc_sim_composition","text":"function: Prepares spatial coordinates locations Validates observed_data provided (must ilr columns xy coords) Calls gstat::predict() generate ILR values nsim realizations. model built conditioning data, predictions automatically honor data sample locations. nmax parameter limits neighborhood used kriging. Extracts simulated ILR columns (identified pattern .sim<N>) Groups ILR values realization Back-transforms realization using compositions::ilrInv() Rescales 0-1 0-100 Stacks results single SpatRaster proper naming Conditional vs. Unconditional: model built data = NULL, realizations independent draws spatial distribution (unconditional). model built data = <conditioning_data>, realizations conditioned values: predictions sample locations exactly reproduce observed values, predictions elsewhere reflect uncertainty updated conditioning data. Important: conditional simulation work, model **must built conditioning data embedded via data parameter gc_ilr_model(). observed_data parameter validation. Conditioning happens automatically model created data. Neighborhood Size Effects (Screen Effect): nmax small relative data density, kriging typically uses nearest nmax observations. can create localized uncertainty estimates may accelerate computation, can also: Introduce discontinuities boundaries neighborhoods Miss spatial structure information distant data Bias predictions far-field data carries important variance information output strictly honors sum constraint: rows sum target_sum (typically 100 percentages) within floating-point precision.","code":""},{"path":"/reference/gc_sim_composition.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate and Back-Transform Compositional Fields — gc_sim_composition","text":"","code":"if (FALSE) { # \\dontrun{ library(sf) library(gstat)  # Assuming ilr_params and model are already defined # (See workflow example in the package README)  # Create simulation grid x.range <- seq(0, 100, by = 5) y.range <- seq(0, 100, by = 5) grid_df <- expand.grid(x = x.range, y = y.range)  # Unconditional simulation: 5 realizations result <- gc_sim_composition(model, grid_df, nsim = 5,                              target_names = c(\"sand\", \"silt\", \"clay\")) print(result)  # Conditional simulation: honor observed data result_cond <- gc_sim_composition(model, grid_df, nsim = 5,                                   target_names = c(\"sand\", \"silt\", \"clay\"),                                   observed_data = sample_df)  # Large dataset: use neighborhood limiting for efficiency result_nmax <- gc_sim_composition(model, grid_df, nsim = 5,                                   target_names = c(\"sand\", \"silt\", \"clay\"),                                   nmax = 15)  # Access results terra::values(result) } # }"},{"path":"/reference/gc_validate_conditioning.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate Conditional Simulation Data Honoring — gc_validate_conditioning","title":"Validate Conditional Simulation Data Honoring — gc_validate_conditioning","text":"Assess quality accuracy conditional kriging extracting kriged predictions conditioning (observation) locations comparing actual observed values. provides quantitative measure well model honors conditioning data ILR space.","code":""},{"path":"/reference/gc_validate_conditioning.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate Conditional Simulation Data Honoring — gc_validate_conditioning","text":"","code":"gc_validate_conditioning(   model,   observed_data,   metrics = c(\"rmse\", \"mae\", \"mean_error\") )"},{"path":"/reference/gc_validate_conditioning.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate Conditional Simulation Data Honoring — gc_validate_conditioning","text":"model gstat kriging model (typically gc_ilr_model()) built conditioning data via data parameter. model must contain observed ILR values sample locations. observed_data data frame sf object original conditioning data, containing columns x, y spatial coordinates columns ilr1, ilr2, etc., ILR values space model. metrics Character vector specifying error metrics compute. Default c(\"rmse\", \"mae\", \"mean_error\"). Options include: \"rmse\": Root mean squared error \"mae\": Mean absolute error \"mean_error\": Mean signed error (bias) \"median_error\": Median absolute error \"sd_error\": Standard deviation errors","code":""},{"path":"/reference/gc_validate_conditioning.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate Conditional Simulation Data Honoring — gc_validate_conditioning","text":"list containing: predictions_at_obs: Data frame kriged predictions observation location observed_values: Data frame original observed ILR values residuals: Difference (observed - predicted) ILR dimension error_metrics: Data frame error statistics (one row per ILR dimension) overall_metrics: Data frame aggregated error statistics across dimensions","code":""},{"path":"/reference/gc_validate_conditioning.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Validate Conditional Simulation Data Honoring — gc_validate_conditioning","text":"Conditional Honoring Assessment: Conditional kriging intended provide spatial predictions exactly (nearly) match observed values conditioning locations. practice, numerical precision limits kriging discretization may result small residuals even perfectly honored data. function: Extracts kriged predictions observation location using model Computes residuals (observed minus predicted) ILR dimension Calculates error metrics (RMSE, MAE, etc.) per dimension overall Returns detailed diagnostics reviewing data honoring quality Interpretation: RMSE close zero indicates excellent data honoring Mean error close zero indicates unbiased predictions Non-zero residuals may indicate: Numerical precision effects (typically < 1e-10) Model convergence issues (investigate univariate kriging) Grid resolution effects (predictions coarse grids may miss exact locations) compositional data (original sand/silt/clay), back-transform RMSE ILR space composition space using ilrInv() assess error original units.","code":""},{"path":"/reference/gc_validate_conditioning.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Validate Conditional Simulation Data Honoring — gc_validate_conditioning","text":"","code":"if (FALSE) { # \\dontrun{ # Assuming model and observed_data are available from gc_ilr_model() # and original data frame with spatial coordinates  # Build model with conditioning data model <- gc_ilr_model(ilr_params, data = conditioning_data)  # Validate conditioning validation <- gc_validate_conditioning(model, conditioning_data)  # Review error metrics print(validation$error_metrics) print(validation$overall_metrics)  # Check for problematic observations high_residuals <- which(abs(validation$residuals$ilr1) > 0.1) if (length(high_residuals) > 0) {   print(\"Observations with large residuals:\")   print(validation$residuals[high_residuals, ]) }  # Visualize residuals vs spatial location plot(validation$predictions_at_obs$x,      validation$residuals$ilr1,      main = \"ILR1 Residuals vs X Coordinate\",      xlab = \"X\", ylab = \"Residual (Observed - Predicted)\") } # }"},{"path":"/reference/gc_vgm_defaults.html","id":null,"dir":"Reference","previous_headings":"","what":"Suggest Reasonable Variogram Default Parameters — gc_vgm_defaults","title":"Suggest Reasonable Variogram Default Parameters — gc_vgm_defaults","text":"Inspect data extent ILR covariance structure suggest ballpark values range, nugget, sill variogram model. convenience function help users get started fine-tuning.","code":""},{"path":"/reference/gc_vgm_defaults.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Suggest Reasonable Variogram Default Parameters — gc_vgm_defaults","text":"","code":"gc_vgm_defaults(ilr_params, extent)"},{"path":"/reference/gc_vgm_defaults.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Suggest Reasonable Variogram Default Parameters — gc_vgm_defaults","text":"ilr_params list returned gc_ilr_params(). extent numeric vector length 4: c(xmin, ymin, xmax, ymax), spatial object (sf, terra) extent can extracted.","code":""},{"path":"/reference/gc_vgm_defaults.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Suggest Reasonable Variogram Default Parameters — gc_vgm_defaults","text":"list containing: range: Suggested range parameter (approximately 1/3 diagonal extent) nugget: Suggested nugget ratio (typically 0.01 0.05 average sill) mean_sill: Mean diagonal covariance terms","code":""},{"path":"/reference/gc_vgm_defaults.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Suggest Reasonable Variogram Default Parameters — gc_vgm_defaults","text":"function: Calculates spatial extent diagonal (Euclidean distance min max) Suggests range ~1/3 extent diagonal Calculates mean diagonal covariance terms representative sill Suggests nugget 1% mean sill heuristics refined using empirical variography (see gc_fit_vgm()).","code":""},{"path":"/reference/gc_vgm_defaults.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Suggest Reasonable Variogram Default Parameters — gc_vgm_defaults","text":"","code":"samples <- data.frame(   sand = c(20, 25, 30, 22),   silt = c(60, 55, 50, 58),   clay = c(20, 20, 20, 20) )  params <- gc_ilr_params(samples) extent <- c(0, 0, 100, 100)  suggestions <- gc_vgm_defaults(params, extent) print(suggestions) #> $range #> [1] 47.14045 #>  #> $nugget #> [1] 0.0001699233 #>  #> $mean_sill #> [1] 0.01699233 #>"}]
