---
title: "Ensemble Post-Processing"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Ensemble Post-Processing}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5
)
```

## Overview

Process simulation outputs into summary statistics, validate constraints, quantify uncertainty, and generate quality metrics.

---

## Workflow

### 1. Compute Summary Statistics

```{r setup_and_stats}
library(geocoda)
library(terra)
library(sf)
library(compositions)

# Synthetic realizations (from geostatistical simulation)
set.seed(42)
n_grid <- 25
n_realizations <- 100

sims_list <- list()
for (i in 1:n_realizations) {
  sand <- rnorm(n_grid, mean = 50, sd = 10)
  silt <- rnorm(n_grid, mean = 30, sd = 8)
  clay <- 100 - sand - silt
  
  total <- sand + silt + clay
  sims_list[[i]] <- data.frame(
    SAND = (sand / total) * 100,
    SILT = (silt / total) * 100,
    CLAY = (clay / total) * 100
  )
}

compute_ensemble_stats <- function(sim_list) {
  n_grid <- nrow(sim_list[[1]])
  components <- colnames(sim_list[[1]])
  
  means <- matrix(NA, n_grid, length(components))
  colnames(means) <- components
  
  sds <- matrix(NA, n_grid, length(components))
  colnames(sds) <- components
  
  q025 <- matrix(NA, n_grid, length(components))
  colnames(q025) <- paste0(components, "_q025")
  
  q975 <- matrix(NA, n_grid, length(components))
  colnames(q975) <- paste0(components, "_q975")
  
  for (j in seq_along(components)) {
    values <- sapply(sim_list, function(df) df[[j]])
    means[, j] <- rowMeans(values)
    sds[, j] <- apply(values, 1, sd)
    q025[, j] <- apply(values, 1, quantile, probs = 0.025)
    q975[, j] <- apply(values, 1, quantile, probs = 0.975)
  }
  
  list(mean = means, sd = sds, q025 = q025, q975 = q975)
}

stats <- compute_ensemble_stats(sims_list)

head(stats$mean[, "SAND"])
mean(stats$sd[, "SAND"])
```

### 2. Validate Constraints

```{r validate}
validate_constraints <- function(sim_list) {
  violations <- 0
  
  for (i in seq_along(sim_list)) {
    sums <- rowSums(sim_list[[i]])
    bad <- sums < 99 | sums > 101
    violations <- violations + sum(bad)
  }
  
  violations
}

n_violations <- validate_constraints(sims_list)
n_violations
```

### 3. Classify Texture

Convert components to USDA soil texture classes:

```{r texture}
classify_texture <- function(sand, silt, clay) {
  texture <- rep(NA, length(sand))
  texture[sand > 85 & clay < 10] <- "Sand"
  texture[sand >= 70 & sand <= 90 & clay < 30] <- "Loamy Sand"
  texture[sand >= 50 & sand < 70 & clay < 27] <- "Sandy Loam"
  texture[sand >= 23 & sand < 52 & silt >= 28 & silt <= 50 & 
          clay >= 7 & clay <= 27] <- "Loam"
  texture[silt > 80 & clay < 10] <- "Silt"
  texture[sand < 45 & silt >= 27 & silt <= 40 & 
          clay >= 27 & clay <= 40] <- "Clay Loam"
  texture[clay >= 40 & sand < 45] <- "Clay"
  texture[is.na(texture)] <- "Other"
  factor(texture)
}

textures_by_realization <- lapply(sims_list, function(df) {
  classify_texture(df$SAND, df$SILT, df$CLAY)
})

# Most likely texture (mode)
most_likely <- sapply(1:n_grid, function(i) {
  class_at_point <- sapply(textures_by_realization, function(v) v[i])
  class_table <- table(class_at_point)
  names(class_table)[which.max(class_table)]
})

table(most_likely)
```

### 4. Uncertainty Quantification

```{r uncertainty}
# Coefficient of Variation
compute_cv <- function(means, sds) {
  cv <- sds / means
  cv[is.infinite(cv)] <- NA
  cv
}

cv_sand <- compute_cv(stats$mean[, "SAND"], stats$sd[, "SAND"])
mean(cv_sand, na.rm = TRUE)

# Prediction interval width
pi_width <- stats$q975[, "SAND_q975"] - stats$q025[, "SAND_q025"]
mean(pi_width)
```

### 5. Quality Report

```{r quality}
generate_quality_report <- function(sim_list, stats) {
  n_realizations <- length(sim_list)
  n_points <- nrow(sim_list[[1]])
  
  all_sums <- sapply(sim_list, function(df) rowSums(df))
  valid_pct <- mean(colSums(apply(all_sums, 1, 
                                   function(x) abs(x - 100) < 1)) / nrow(all_sums)) * 100
  
  mean_sand <- mean(stats$mean[, "SAND"], na.rm = TRUE)
  mean_sd <- mean(stats$sd[, "SAND"], na.rm = TRUE)
  
  c(
    n_realizations = n_realizations,
    n_points = n_points,
    valid_pct = valid_pct,
    mean_sand = mean_sand,
    mean_sd = mean_sd
  )
}

report <- generate_quality_report(sims_list, stats)
report
```

### 6. Cross-Validation

```{r crossval}
evaluate_cv <- function(sim_list) {
  n_points <- nrow(sim_list[[1]])
  holdout <- sample(1:n_points, size = n_points/2)
  
  residuals <- numeric(length(holdout))
  for (i in seq_along(holdout)) {
    point_idx <- holdout[i]
    observed <- sims_list[[1]]$SAND[point_idx]
    predicted <- mean(sapply(sims_list[-1], 
                             function(df) df$SAND[point_idx]))
    residuals[i] <- observed - predicted
  }
  
  list(
    mae = mean(abs(residuals)),
    rmse = sqrt(mean(residuals^2)),
    residuals = residuals
  )
}

cv_results <- evaluate_cv(sims_list)
cv_results$mae
cv_results$rmse

---

## Export to Rastersnbsp

```{r export}
export_as_rasters <- function(stats) {
  raster_template <- rast(
    ncols = 5, nrows = 5,
    extent = ext(0, 100, 0, 100),
    crs = "WGS84"
  )
  
  sand_mean <- setValues(raster_template, stats$mean[, "SAND"])
  clay_mean <- setValues(raster_template, stats$mean[, "CLAY"])
  sand_sd <- setValues(raster_template, stats$sd[, "SAND"])
  
  stack <- c(sand_mean, clay_mean, sand_sd)
  names(stack) <- c("SAND_mean", "CLAY_mean", "SAND_sd")
  stack
}

raster_outputs <- export_as_rasters(stats)
raster_outputs
```

---

## Key points

[OK] Summarize realizations into mean, SD, quantiles
[OK] Validate compositional constraints
[OK] Classify components to texture classes
[OK] Quantify uncertainty (CV, interval width)
[OK] Generate automated quality reports
[OK] Cross-validate model performance
[OK] Export to GIS-ready raster formats

---

## References

- `?gc_aggregate_realizations()` -- Summary statistics
- `?gc_ensemble_quality_report()` -- Automated QA/QC
- `?gc_sim_composition()` -- Simulation details
