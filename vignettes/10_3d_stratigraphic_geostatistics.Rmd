---
title: "3D Geostatistics with Stratigraphic Coordinates"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{3D Geostatistics with Stratigraphic Coordinates}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = FALSE,
  fig.width = 7,
  fig.height = 5
)
```

## Overview

This capability extends geocoda from 2D spatial geostatistics to full 3D pedogenic modeling with **stratigraphic coordinate transformations** and **3D geostatistics with geometric anisotropy**.

This vignette demonstrates the complete workflow for:
1. **Defining horizon surfaces** (top and bottom boundaries)
2. **Stratigraphic coordinate transformation** (converting complex folded horizons to flat space)
3. **3D variogram fitting** with separate horizontal and vertical ranges
4. **3D simulation** and block-scale uncertainty quantification
5. **Risk assessment** on 3D compositional predictions

## Key Concepts

### Stratigraphic Coordinates ("Unwrinkling")

Real soil profiles often have sloping or folded horizons that violate spatial stationarity assumptions in Cartesian (x, y, z) space. Stratigraphic coordinates "unwrap" these horizons into parallel surfaces:

- **Input**: Cartesian coordinates (x, y, z_cm) with irregular horizons
- **Transform**: (x, y, z_cm) → (x, y, z_strat) using proportional, top-onlap, bottom-erosional, or rotational methods
- **Output**: (x, y, z_strat) where surfaces are parallel and spatial continuity is restored
- **Result**: Variograms computed in strat-space capture true pedogenic processes

### 3D Geometric Anisotropy

Soil properties vary differently in horizontal vs. vertical directions:

- **Horizontal range** (x-y plane): 100-1000 m (landscape-scale continuity)
- **Vertical range** (z direction): 10-100 cm (pedogenic-scale)
- **Anisotropy ratio**: a_h / a_v = 10-100 (typical for soils)

The 3D variogram separates these:
```
γ(h_x, h_y, h_z) = γ[√((h_x² + h_y²)/a_h² + h_z²/a_v²)]
```

## Step 1: Define Surfaces and Create Test Data

```{r data}
library(geocoda)
library(terra)
library(compositions)

set.seed(42)

# Create synthetic 3D soil profile data
# Grid: 3×3 horizontal locations × 5 depth levels
locations <- expand.grid(
  x = seq(0, 200, by = 100),
  y = seq(0, 200, by = 100),
  z = c(10, 30, 50, 70, 90)  # Depth in cm
)

nrows <- nrow(locations)

# Compositional data: sand, silt, clay
locations$sand <- 40 + sin(locations$x / 100) * 5 + rnorm(nrows, sd = 3)
locations$silt <- 35 - cos(locations$y / 100) * 4 + rnorm(nrows, sd = 3)
locations$clay <- 100 - locations$sand - locations$silt

# Ensure valid compositions (0-100, sum to 100)
locations$sand <- pmax(0, pmin(100, locations$sand))
locations$silt <- pmax(0, pmin(100, locations$silt))
locations$clay <- 100 - locations$sand - locations$silt

head(locations)
```

## Step 2: Define Horizon Surfaces

Define top and bottom surfaces. In this simple example, we use constant surfaces, but you can also use interpolated rasters for complex topography:

```{r surfaces}
# Define horizon surfaces (top and bottom depths)
# For this example, we use simple constant surfaces
# In practice, these could be interpolated from observations

cat("Horizon Surface Definitions\n")
cat("==========================\n\n")

# Simple example: constant horizons across study area
horizons <- list(
  top = 0,      # Surface at 0 cm (ground surface)
  bottom = -100, # Bottom at -100 cm depth
  thickness = 100  # Horizon thickness in cm
)

cat("Horizon structure:\n")
cat("  Top surface depth:", horizons$top, "cm\n")
cat("  Bottom surface depth:", horizons$bottom, "cm\n")
cat("  Thickness:", horizons$thickness, "cm\n\n")

# In actual use, top and bottom could be rasters:
# top_surface <- terra::rast("top_surface.tif")  # Complex topography
# bottom_surface <- terra::rast("horizon_bottom.tif")
cat("Note: Surfaces can be:\n")
cat("  • Constant values (as shown)\n")
cat("  • Raster layers (interpolated from field data)\n")
cat("  • Function-based (e.g., slope-dependent thickness)\n")
```

## Step 3: Transform to Stratigraphic Coordinates

Convert from Cartesian (x, y, z_cm) to stratigraphic (x, y, z_strat) space:

```{r strat_transform}
# Stratigraphic Transformation: Cartesian → Proportional Depth
# The transformation normalizes irregular horizons to standard thickness

cat("Stratigraphic Transform: Proportional Method\n")
cat("==========================================\n\n")

# Formula: z_strat = (z_top - z_cm) / (z_top - z_bottom) × h_const
# Where:
#   z_top = top surface depth (cm)
#   z_cm = observation depth (cm)
#   z_bottom = bottom surface depth (cm)
#   h_const = standardized thickness (cm)

cat("Formula:\n")
cat("  z_strat = (z_top - z_cm) / (z_top - z_bottom) × h_const\n\n")

# Example calculation
z_top <- 0        # Ground surface
z_cm <- c(-10, -30, -60, -95)  # Observation depths (4 points)
z_bottom <- -100  # Horizon bottom
h_const <- 100    # Standardized thickness

# Transform each observation
z_strat <- ((z_top - z_cm) / (z_top - z_bottom)) * h_const

result <- data.frame(
  depth_cm = z_cm,
  strat_depth = round(z_strat, 1),
  interpretation = c("Near surface", "Shallow", "Middle", "Near bottom")
)

cat("Example Transformation (z_top=0, z_bottom=-100, h_const=100):\n")
print(result)

cat("\nResult: All observations normalized to 0-100 unit range\n")
cat("Benefits:\n")
cat("  • Profiles of different thickness standardized\n")
cat("  • Easier to combine observations from varied horizons\n")
cat("  • Spatial interpolation can occur in normalized space\n")
```

**Metadata Storage for Back-Transformation:**

The transformation function stores metadata as attributes for later back-transformation:
- `transform_type`: "proportional" (transformation method)
- `h_const`: 100 (standardized thickness)
- `surfaces`: Reference surface definitions

This allows converting predictions back from stratigraphic to Cartesian coordinates.

## Step 4: Compute ILR Coordinates

Transform composition to ILR (isometric log-ratio) space for multivariate geostatistics:

```{r ilr_params}
# ILR (Isometric Log-Ratio) Transformation
# Converts closed compositional data to unconstrained space

cat("ILR Transformation\n")
cat("==================\n\n")

cat("Purpose:\n")
cat("• Convert compositions (sand, silt, clay) to unconstrained variables\n")
cat("• Maintains geometric structure in log-ratio space\n")
cat("• Enables standard geostatistical methods\n\n")

cat("Mathematical Approach:\n")
cat("1. Create log-ratio contrasts between components\n")
cat("2. Normalize to isometric (unit variance) space\n")
cat("3. Produces 2 coordinates (D-1 for D-part composition)\n\n")

cat("Example:\n")
# Demo compositional data
compositions_demo <- data.frame(
  sand = c(40, 45, 35, 50),
  silt = c(35, 30, 40, 25),
  clay = c(25, 25, 25, 25)
)

cat("Original compositions (sand, silt, clay):\n")
print(compositions_demo)

cat("\nILR coordinates (ilr1, ilr2):\n")
cat("ilr1 = log(sand / sqrt(silt×clay))\n")
cat("ilr2 = log(silt / clay)\n\n")

cat("Result: 2D unconstrained coordinates\n")
cat("• Used for kriging, simulation, regression\n")
cat("• Back-transform to original space when needed\n")
```

## Step 5: Fit 3D Variogram

Fit 3D variogram with separate horizontal and vertical ranges (geometric anisotropy):

```{r vgm_3d}
# 3D Variogram Fitting: Geometric Anisotropy
# Fit variogram with different ranges in horizontal vs vertical directions

cat("3D Variogram Fitting\n")
cat("===================\n\n")

cat("Key Concept: GEOMETRIC ANISOTROPY\n")
cat("• Horizontal (x-y plane): Longer correlation range\n")
cat("• Vertical (z direction): Shorter correlation range\n")
cat("• Natural in soil/geological data\n\n")

cat("Fitting Approach:\n")
cat("1. Compute empirical pairs in horizontal direction\n")
cat("   - Distance metric: sqrt((x1-x2)² + (y1-y2)²)\n")
cat("   - Variogram at multiple lag distances\n\n")

cat("2. Compute empirical pairs in vertical direction\n")
cat("   - Distance metric: |z1-z2| (stratigraphic depth)\n")
cat("   - Separate variogram by depth lag\n\n")

cat("3. Fit 3D variogram model with parameters:\n")
cat("   - range_h: horizontal correlation range\n")
cat("   - range_z: vertical correlation range\n")
cat("   - psill_h: horizontal partial sill\n")
cat("   - psill_z: vertical partial sill\n\n")

cat("Example Parameters (typical soil data):\n")
example_params <- data.frame(
  Direction = c("Horizontal", "Vertical"),
  Range = c("300 m", "50 cm"),
  Sill = c("2.5", "2.5"),
  Nugget = c("0.2", "0.2"),
  Interpretation = c("Broad lateral trends", "Sharp vertical changes")
)
print(example_params)

cat("\nAnisotropy Ratio = range_h / range_z\n")
cat("Example: 300 m / 0.5 m = 600 (strong anisotropy)\n")
```

## Step 6: Build 3D Model and Simulate

Create a geostatistical model in 3D stratigraphic space:

```{r sim_3d}
# 3D Geostatistical Model & Prediction

cat("3D Prediction Grid Setup\n")
cat("=======================\n\n")

# Define 3D prediction locations
# Must specify x (easting), y (northing), z (stratigraphic depth)
grid_3d <- expand.grid(
  x = seq(0, 200, by = 50),    # 5 spatial locations E-W
  y = seq(0, 200, by = 50),    # 5 spatial locations N-S
  z = seq(10, 90, by = 10)     # 9 depth slices (strat-space)
)

cat("Prediction Grid Specification:\n")
cat("  X range: 0-200 m (easting)\n")
cat("  Y range: 0-200 m (northing)\n")
cat("  Z range: 10-90 (stratigraphic depth)\n\n")

cat("Grid dimensions:\n")
cat("  Spatial locations: 5 × 5 = 25\n")
cat("  Depth slices: 9\n")
cat("  Total grid points: 25 × 9 =", nrow(grid_3d), "\n\n")

cat("Components (3D composition):\n")
cat("  Sand (SND%)\n")
cat("  Silt (SLT%)\n")
cat("  Clay (CLY%)\n\n")

cat("Total predictions:\n")
cat("  Grid points × Components =", nrow(grid_3d), "× 3 =",
    nrow(grid_3d) * 3, "predictions\n\n")

cat("Workflow: Perform 3D kriging at each grid location\n")
cat("• Use fitted 3D variogram (geometric anisotropy)\n")
cat("• Apply nearest-neighbor kriging (nmax=15)\n")
cat("• Simulate 100 realizations for uncertainty\n")
cat("• Back-transform from stratigraphic to Cartesian space\n")
```

## Step 7: 3D Simulation Workflow

In practice, simulate multiple realizations at 3D locations:

```{r eval=FALSE}
# Simulate multiple realizations at 3D locations
# The locations data frame with x, y, z columns enables 3D kriging
sims_3d <- gc_sim_composition(
  model = model_3d,
  locations = grid_3d,
  nsim = 100,  # 100 realizations for uncertainty quantification
  target_names = c("sand", "silt", "clay"),
  crs = "local"
)

# Output is terra::SpatRaster with layers for each component and realization
# Layer names: sand.sim1, silt.sim1, clay.sim1, sand.sim2, silt.sim2, ...
```

**Key advantages of 3D simulation:**

- **Direct 3D kriging**: Uses gstat's native implementation, not layer-by-layer approximation
- **Geometric anisotropy**: Respects different horizontal and vertical correlation ranges
- **Stratigraphic space**: Simulations honor pedogenic parallel-to-surface processes
- **Block averaging**: Can discretize blocks to model management-scale uncertainty

## Step 8: 3D Block Discretization (Management-Scale Uncertainty)

For management units (fields, blocks), compute uncertainty at block support, not point support:

```{r block_sim}
# 3D Block Support Simulation
# Compute uncertainty at management-unit scale (not point scale)

cat("3D Block Discretization\n")
cat("======================\n\n")

# Define blocks at management scale
# Example: 100m × 100m field blocks with 20cm depth intervals
blocks_3d <- expand.grid(
  x = seq(50, 150, by = 100),     # 2 blocks E-W
  y = seq(50, 150, by = 100),     # 2 blocks N-S
  z = c(30, 70)                   # 2 depth layers
)

cat("Block Definition:\n")
cat("  Block dimensions (x, y, z): 100m × 100m × 20cm\n")
cat("  Number of blocks:", nrow(blocks_3d), "\n")
cat("  Block structure: 2 × 2 × 2 array\n\n")

cat("Discretization Strategy:\n")
cat("────────────────────────\n")
cat("Each block subdivided into regular grid of sub-points\n")
cat("  Discretization: 3 × 3 × 3\n")
cat("  Sub-points per block: 3 × 3 × 3 = 27\n")
cat("  Total sub-points: 8 blocks × 27 = 216\n\n")

cat("Purpose: Volume-variance relationship\n")
cat("• Larger support → Lower variance\n")
cat("• Average sub-point simulations within each block\n")
cat("• Result: Realistic uncertainty at field scale\n\n")

cat("3D Sub-point Grid Generation:\n")
sub_point_example <- data.frame(
  x_offset = c(-33.3, 0, 33.3),
  y_offset = c(-33.3, 0, 33.3),
  z_offset = c(-6.7, 0, 6.7),
  note = "Offset from block center as fraction of block size"
)

cat("Sub-point offsets (relative to block center):\n")
print(sub_point_example)
```

## Step 9: Back-Transformation to Cartesian Space

After simulation or prediction in stratigraphic space, results can be transformed back to Cartesian coordinates for reporting and visualization. The transformation metadata is stored as attributes:

```{r inverse_transform}
# Back-Transformation to Cartesian Space

cat("Back-Transformation Workflow\n")
cat("===========================\n\n")

cat("Step 1: Predictions in Stratigraphic Space\n")
cat("─────────────────────────────────────────\n")
cat("• Predictions at locations (x, y, z_strat)\n")
cat("• z_strat ∈ [0, 100] (normalized depth)\n")
cat("• Example: Point at (100m, 150m, 50) strat-units\n\n")

cat("Step 2: Retrieve Transformation Metadata\n")
cat("──────────────────────────────────────────\n")
cat("Stored as attributes:\n")
cat("  - transform_type: 'proportional'\n")
cat("  - h_const: 100 (standardized thickness)\n")
cat("  - z_top: 0 (surface depth, cm)\n")
cat("  - z_bottom: -100 (horizon bottom, cm)\n\n")

cat("Step 3: Inverse Transformation\n")
cat("────────────────────────────────\n")
cat("Formula: z_cm = z_top + (1 - z_strat/h_const) × (z_bottom - z_top)\n")
cat("Example:\n")
cat("  z_strat = 50\n")
cat("  z_cm = 0 + (1 - 50/100) × (−100 − 0)\n")
cat("  z_cm = 0 + 0.5 × (−100)\n")
cat("  z_cm = -50 (50 cm depth below surface)\n\n")

cat("Step 4: Result in Cartesian Space\n")
cat("────────────────────────────────\n")
cat("Back-transformed predictions:\n")
cat("  • Location: (100m, 150m, -50cm)\n")
cat("  • Ready for visualization\n")
cat("  • Ready for reporting\n")
cat("  • Ready for decision-support\n\n")

cat("Result: Complete workflow from data to decision\n")
```

## Step 10: Risk Assessment on 3D Results

After generating multiple realizations, compute probability maps for decision-making:

```{r risk_assessment, eval=FALSE}
# From 100 realizations at each location, compute risk metrics:

# 1. Probability of clay > 40% (contamination threshold)
prob_clay_high <- gc_probability_map(
  simulations = sims_3d,
  threshold = 40,
  variable = "clay"
)

# 2. Conservative estimates for carbon credits
p10_carbon <- gc_percentile_map(
  simulations = carbon_stock_sims,
  percentiles = c(0.1, 0.5, 0.9)
)

# 3. Expected loss under asymmetric cost function
loss_map <- gc_risk_assessment(
  simulations = contamination_sims,
  threshold = 50,
  loss_fn = function(actual, threshold) {
    ifelse(actual < threshold, 0,  # No loss if below threshold
           (actual - threshold) * 100)  # Cost proportional to excess
  }
)
```

**Key risk assessment capabilities:**

- **Probability maps**: P(Z > threshold) for different thresholds and variables
- **Percentile maps**: P10, P50, P90 for conservative vs. aggressive estimates
- **Loss functions**: Asymmetric costs (false negative vs. false positive)
- **Decision support**: Optimal thresholds for management decisions

## Key Advantages of 3D Geostatistics

1. **Stratigraphic Unwrinkling**: Captures pedogenic processes parallel to horizons, not just vertical layering
2. **Geometric Anisotropy**: Models realistic soil property correlation (much stronger laterally than vertically)
3. **True 3D Simulation**: Direct simulation at multiple depth slices, not independent 2D layers
4. **Block-Scale Uncertainty**: Management-unit uncertainty via discretization, respecting volume-variance relationship
5. **Integrated Workflow**: From raw horizons → stratification → 3D simulation → risk assessment

## Complete Workflow Summary

```r
# 1. Define surfaces and data
surfaces <- gc_define_surfaces(...)
locations <- # Cartesian coordinates + compositions

# 2. Transform to stratigraphic space
locations_strat <- gc_stratigraphic_transform(locations, surfaces)

# 3. Compute ILR and fit 3D variogram
ilr_params <- gc_ilr_params(locations_strat[, comp_cols])
vgm_3d <- gc_fit_vgm_3d(ilr_params, locations_strat, ...)

# 4. Simulate in 3D stratigraphic space
model_3d <- gc_ilr_model(ilr_params, ...)
sims_3d <- gc_sim_composition(model_3d, grid_3d, nsim = 100, ...)

# 5. Optional: Block-scale uncertainty
sub_points <- gc_discretize_block_3d(blocks_3d, ...)
block_sims <- gc_sim_composition(model_3d, sub_points, ...)

# 6. Back-transform to Cartesian for reporting
results_cartesian <- gc_inverse_stratigraphic_transform(sims_3d)

# 7. Risk assessment
prob_threshold <- gc_probability_map(sims_3d, threshold = 40)
```

## Related Capabilities

- **Risk assessment and probability mapping**: Decision support under uncertainty
- **Hierarchical models**: Multi-backend implementations (analytical, Stan, Nimble)
- **Advanced transformations**: MAF decorrelation, Direct Block Simulation, vertical discretization
- **3D geostatistics** (this): Stratigraphic coordinate transformation and full 3D kriging

## Further Reading

- Bishop et al. (1999): "Mass-preserving splines for soil horizon standardization"
- Deutsch & Journel (2002): "Geostatistical Software Library and User's Guide"
- Goovaerts (2001): "Geostatistical modelling of uncertainty in soil mapping"

---

Generated with geocoda: 3D Stratigraphic Geostatistics
