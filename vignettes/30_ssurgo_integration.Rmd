---
title: "SSURGO Integration"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{SSURGO Integration}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)
```

## Overview

Query SSURGO live data and integrate with field observations for regional soil mapping.

---

## Query by Geographic Extent

```{r query_extent}
library(geocoda)
library(sf)
library(soilDB)
library(compositions)

# Define study area (5km x 5km)
study_bbox <- st_bbox(c(
  xmin = -93.5, ymin = 41.5,
  xmax = -93.45, ymax = 41.55
), crs = 4326)

# Query SDA
ssurgo_data <- gc_fetch_sda_properties(
  extent = study_bbox,
  depth_range = c(0, 30),
  property_names = c("sandtotal_r", "silttotal_r", "claytotal_r"),
  weight_by = "comppct",
  timeout = 60,
  use_cache = TRUE
)

head(ssurgo_data)
```

---

## Combine Field + SSURGO

```{r combine}
# Field observations
field_obs <- st_as_sf(
  field_data[, c("x", "y", "SAND", "SILT", "CLAY")],
  coords = c("x", "y"), crs = 4326
)

# SSURGO observations (grid centroids)
ssurgo_pts <- st_as_sf(
  ssurgo_data[, c("x", "y", "sandtotal_r", "silttotal_r", "claytotal_r")],
  coords = c("x", "y"), crs = 4326
)
names(ssurgo_pts) <- c("SAND", "SILT", "CLAY", "geometry")

# Combine
combined <- rbind(
  cbind(field_obs, source = "field"),
  cbind(ssurgo_pts, source = "ssurgo")
)

nrow(combined)
```

---

## Build Model from Combined Data

```{r model}
# Extract compositions
comps <- combined[, c("SAND", "SILT", "CLAY")]

# ILR parameters
ilr_params <- gc_ilr_params(comps)

# Prepare spatial data with ILR
obs_ilr <- ilr(acomp(comps))
colnames(obs_ilr) <- c("ilr1", "ilr2")

vgm_data <- data.frame(
  st_coordinates(combined),
  ilr1 = obs_ilr[, 1],
  ilr2 = obs_ilr[, 2]
)
names(vgm_data)[1:2] <- c("x", "y")

# Fit variogram
vgm_fitted <- gc_fit_vgm(ilr_params, data = vgm_data)

# Build model
model <- gc_ilr_model(ilr_params, variogram_model = vgm_fitted)
```

---

## Simulate

```{r simulate}
# Create prediction grid
pred_grid <- st_make_grid(study_bbox, cellsize = 500) |>
  st_as_sf() |>
  st_centroid()

pred_sf <- st_coordinates(pred_grid) |>
  as.data.frame() |>
  st_as_sf(coords = c("X", "Y"), crs = 4326)

# Generate realizations
sims <- gc_sim_composition(
  model = model,
  locations = pred_sf,
  nsim = 10,
  target_names = c("SAND", "SILT", "CLAY")
)
```

---

## Benefits

[OK] Live SSURGO queries reduce manual data prep
[OK] Component-level data automatically aggregated
[OK] 24-hour caching prevents redundant queries
[OK] Seamless field + SSURGO integration
[OK] Scalable to large regional surveys

---

## References

- `?gc_fetch_sda_properties()` -- SDA queries
- `?gc_ilr_model()` -- Model specification
- Depth range `c(0, 30)` extracted surface horizon data
- Component percentages available for weighting

**Explanation of columns:**
- `mukey`: Map unit key (unique SSURGO identifier)
- `compname`: Component name (soil series, e.g., "Harps")
- `comppct`: Percent of map unit represented by component
- `sandtotal_r`, `silttotal_r`, `claytotal_r`: Composition % (should sum ~100)

---

## Step 2: Alternative Query by Map Unit Keys

If you know specific SSURGO map units, query directly by keys:

```{r step2_query_by_mukey}
# Known Iowa map units (example)
iowa_mukeys <- c("463168", "463169", "463171", "463172", "463175")

# Direct query by map unit keys
ssurgo_mukey <- gc_fetch_sda_properties(
  map_unit_keys = iowa_mukeys,
  depth_range = c(0, 30),
  property_names = c("sandtotal_r", "silttotal_r", "claytotal_r"),
  use_cache = TRUE,
  verbose = TRUE
)

nrow(ssurgo_mukey)  # Total component records
```

**When to use:**
- You've identified specific map units of interest
- Faster than extent-based queries
- Good for targeted soil survey areas

---

## Step 3: Process and Aggregate Components

Transform component-level data to map-unit compositions using hierarchical aggregation:

```{r step3_aggregate_components}
# Method 1: Weighted mean (standard - each component weighted by %)
ssurgo_agg_weighted <- gc_process_ssurgo_components(
  ssurgo_data = ssurgo_data,
  component_cols = c("sandtotal_r", "silttotal_r", "claytotal_r"),
  aggregate_method = "weighted_mean",
  weight_field = "comppct",
  depth_weights = TRUE,
  min_confidence = 0,
  verbose = TRUE
)

# View aggregated compositions (one record per map unit)
head(ssurgo_agg_weighted$compositions)

# Component summary statistics
head(ssurgo_agg_weighted$component_summary)
```

**Aggregation methods:**

| Method | Use Case | Example |
|--------|----------|---------|
| `weighted_mean` | Default best practice; weight each component by its % of map unit | MU = 60% Harps (sand-rich) + 40% Mahaska (clay-rich) -> weighted avg |
| `component_best` | Use only dominant component (>50% typically) | Simplify for single-component map units |
| `representative_component` | SSURGO-designated representative component | Use SSURGO's selected "representative" label |

**Output interpretation:**
- `n_map_units`: Number of unique map units (e.g., 3-5 for typical soil survey)
- `n_components_raw`: Total component records processed (usually 2-4x map units)
- Composition sum check: Should be ~100% for valid data

---

## Step 4: Combine Field Data with SSURGO

Integrate field observations with SSURGO compositions for hierarchical modeling:

```{r step4_combine_field_ssurgo}
# Example field observations (3 soil pits)
field_data <- data.frame(
  pit_id = c("P1", "P2", "P3"),
  sandtotal_r = c(52, 38, 65),  # Sand %
  silttotal_r = c(28, 35, 22),  # Silt %
  claytotal_r = c(20, 27, 13),  # Clay %
  zone = c("Zone1", "Zone2", "Zone1"),
  depth_cm = c(25, 25, 25)
)

# Combine field + SSURGO: field data has priority (higher weight)
ilr_data <- gc_prepare_hierarchical_data(
  ssurgo_compositions = ssurgo_agg_weighted$compositions,
  field_observations = field_data,
  component_cols = c("sandtotal_r", "silttotal_r", "claytotal_r"),
  zone_assignment = NULL,  # Assign zones separately if needed
  combine_method = "field_priority",  # Priority: field > SSURGO
  verbose = TRUE
)

# Inspect combined data
head(ilr_data)  # Shows field pits + SSURGO map units combined

# Check sources and weights
table(ilr_data$source)  # Count by source
```

**Combine strategies:**

| Strategy | Weights | Use Case |
|----------|---------|----------|
| `field_priority` | Field=1.0, SSURGO=0.6 | Field data is more reliable (measured); SSURGO fills gaps |
| `equal_weight` | Both >=0.8 | Both sources equally trusted |
| `ssurgo_only` | SSURGO only | No field data; rely entirely on SSURGO |

**Key insight:** Combined regional SSURGO + local field data yields more robust kriging models than either source alone.

---

## Step 5: Transform to ILR Space

The data is automatically transformed to ILR coordinates by `gc_prepare_hierarchical_data()`:

```{r step5_ilr_transform}
# ILR columns are in ilr_data already (created by function)
names(ilr_data)

# Verify ILR coordinates exist
head(ilr_data[, c("ilr1", "ilr2", "source", "weight")])

# Check data structure: should have field pits + SSURGO map units
cat("Total records:", nrow(ilr_data), "\n")
cat("Sources:", paste(unique(ilr_data$source), collapse=", "), "\n")
cat("Weight distribution:\n")
print(summary(ilr_data$weight))
```

**ILR transformation rationale:**
- Compositional data (sand, silt, clay) lives on a simplex, not Euclidean space
- ILR (Isometric Log-Ratio) maps compositions to Euclidean space
- `ilr1`, `ilr2` are orthogonal coordinates suitable for kriging

---

## Step 6: Spatial Query Optimization (Large Extents)

For large geographic areas, use tiling and parallel queries:

```{r step6_query_optimization}
# Large extent (50km x 50km regional survey)
large_extent <- st_bbox(c(
  xmin = -93.6, ymin = 41.4,
  xmax = -93.2, ymax = 41.8
), crs = 4326)

# Optimize queries: tile-based + parallel
optimized_results <- gc_optimize_sda_queries(
  extent = large_extent,
  tile_size = 0.25,  # 0.25 degree tiles (~25km each)
  n_workers = 4,     # 4 parallel workers
  timeout_per_tile = 30,
  fallback_cache = TRUE,  # Use cache if query fails
  priority = "speed",  # "speed", "completeness", or "balanced"
  verbose = TRUE
)

# Query metrics
print(attr(optimized_results, "total_query_time"))  # Total seconds
print(attr(optimized_results, "n_tiles"))           # Number of tiles
print(attr(optimized_results, "success_rate"))      # Success rate
```

**Optimization strategies:**

| Priority | Tile Size | Use Case |
|----------|-----------|----------|
| `speed` | Large (0.5 deg) | Quick overview; fewer queries |
| `completeness` | Small (0.1 deg) | Detailed coverage; more queries |
| `balanced` | Medium (0.25 deg) | Default; good tradeoff |

---

## Step 7: Build Hierarchical Shrinkage Model from SDA Data

Fit a hierarchical shrinkage model using combined field + SSURGO data:

**Note:** This uses empirical Bayes shrinkage estimation (analytical), not MCMC sampling.
For true Bayesian MCMC inference, use geocoda v0.3.0+.

```{r step7_hierarchical_model}
# Simplified example: assume ilr_data has coordinates + zones
# (In practice: would use field pit locations + assigned SSURGO extents)

# Define hierarchical zone structure
hierarchy <- gc_define_hierarchy(
  zone_names = unique(ilr_data$zone),
  component_names = c("sandtotal_r", "silttotal_r", "claytotal_r")
)

# Set shrinkage priors: "moderate" pools 20% of variance toward global mean
priors <- gc_set_hierarchy_priors(
  hierarchy = hierarchy,
  pooling = "moderate",  # "none", "weak", "moderate", or "strong"
  fit_data = ilr_data  # Auto-compute global stats from data
)

# Fit hierarchical shrinkage model (fast analytical estimation)
model_hier <- gc_fit_hierarchical_model(
  data = ilr_data,
  prior_spec = priors,
  verbose = TRUE
)

# Zone summaries (shrinkage-pooled estimates)
gc_extract_zone_posterior(model_hier, zone = unique(ilr_data$zone)[1])
```

**Model components:**
- **Global mean**: Estimated from combined field + SSURGO data
- **Zone-specific terms**: Account for regional variation
- **Shrinkage**: Partial pooling of zone estimates toward global mean (controlled by pooling_coefficient)
- **Zone estimates**: Analytical estimates from empirical Bayes shrinkage

---

## Step 8: Generate Simulations and Products

Create probabilistic soil property maps:

```{r step8_simulations}
# Generate realizations on prediction grid
pred_grid <- sf::st_make_grid(
  x = large_extent, cellsize = 0.01, crs = 4326  # 1km cells
)

# Simulate using hierarchical model
realizations <- gc_sim_hierarchical(
  model = model_hier,
  locations = pred_grid,
  n_realizations = 100,
  method = "kriging",
  verbose = TRUE
)

# Convert to raster stacks
stacks <- gc_hierarchy_to_stacks(
  realizations = realizations,
  component_names = c("sand", "silt", "clay"),
  resolution = 0.01,
  crs = 4326
)

# Compute statistics from realizations
mean_sand <- raster::mean(stacks$sand_realizations)
sd_clay <- raster::calc(stacks$clay_realizations, fun = sd)

# Export for GIS
raster::writeRaster(mean_sand, "sda_mean_sand.tif", overwrite=TRUE)
raster::writeRaster(sd_clay, "sda_sd_clay.tif", overwrite=TRUE)
```

---

## Step 9: Validation and Diagnostics

Assess model quality using cross-validation:

```{r step9_diagnostics}
# Cross-validation
cv_results <- gc_cross_validate(
  model = model_hier,
  data = ilr_data,
  coords_cols = c("x", "y"),
  ilr_cols = c("ilr1", "ilr2")
)

# Performance metrics
cat("CV RMSE:", round(sqrt(mean(cv_results$residual^2)), 3), "\n")
cat("95% PI coverage:", mean(cv_results$in_95pi), "\n")

# Stationarity test (assume model is valid across zones)
stationarity <- gc_test_stationarity_cv(
  data = ilr_data,
  coords_cols = c("x", "y"),
  ilr_cols = c("ilr1", "ilr2"),
  window_size = 0.25  # 0.25 deg windows
)

if (stationarity$p_value > 0.05) {
  cat("[OK] Stationarity assumption OK (p =", round(stationarity$p_value, 3), ")\n")
} else {
  cat("[FAIL] Non-stationary model detected (p =", round(stationarity$p_value, 3), ")\n")
  cat("  -> Consider zone-specific models (see hierarchical zones workflow)\n")
}

# Entropy-based uncertainty assessment
entropy_results <- gc_compute_entropy(realizations, n_bins = 10)
head(entropy_results)  # High entropy = high uncertainty in composition
```

---

## Complete Workflow Example: Iowa Soil Survey

Here's a complete end-to-end workflow integrating all steps:

```{r complete_workflow, eval=FALSE}
library(geocoda)
library(sf)
library(soilDB)
library(compositions)

# ====================================================================
# SDA/SSURGO Integration Workflow
# ====================================================================

# 1. QUERY: Fetch SSURGO for study area
study_area <- st_bbox(c(xmin=-93.5, ymin=41.5, xmax=-93.4, ymax=41.6), 
                       crs=4326)

ssurgo_raw <- gc_fetch_sda_properties(
  extent = study_area,
  depth_range = c(0, 30),
  property_names = c("sandtotal_r", "silttotal_r", "claytotal_r"),
  use_cache = TRUE
)

# 2. AGGREGATE: Process components to map units
ssurgo_agg <- gc_process_ssurgo_components(
  ssurgo_data = ssurgo_raw,
  component_cols = c("sandtotal_r", "silttotal_r", "claytotal_r"),
  aggregate_method = "weighted_mean"
)

# 3. COMBINE: Integrate field observations
field_obs <- data.frame(  # 3 example field pits
  sandtotal_r = c(50, 40, 60),
  silttotal_r = c(30, 35, 25),
  claytotal_r = c(20, 25, 15)
)

ilr_combined <- gc_prepare_hierarchical_data(
  ssurgo_compositions = ssurgo_agg$compositions,
  field_observations = field_obs,
  component_cols = c("sandtotal_r", "silttotal_r", "claytotal_r"),
  combine_method = "field_priority"
)

# 4. MODEL: Fit hierarchical shrinkage model (analytical, not MCMC)
hierarchy <- gc_define_hierarchy(
  zone_names = c("Zone1", "Zone2"),
  component_names = c("sandtotal_r", "silttotal_r", "claytotal_r")
)

priors <- gc_set_hierarchy_priors(
  hierarchy = hierarchy,
  pooling = "moderate",
  fit_data = ilr_combined
)

model <- gc_fit_hierarchical_model(
  data = ilr_combined,
  prior_spec = priors
)

# 5. SIMULATE: Generate realizations
realizations <- gc_sim_hierarchical(
  model = model,
  locations = sf::st_make_grid(study_area, cellsize=0.01, crs=4326),
  n_realizations = 100
)

# 6. VALIDATE: Cross-validation assessment
cv <- gc_cross_validate(model, ilr_combined, c("x","y"), c("ilr1","ilr2"))
cat("CV RMSE:", round(sqrt(mean(cv$residual^2)), 3), "\n")

# 7. EXPORT: Save products
products <- gc_obtain_ensemble_stats(realizations, 
                                      c("sand", "silt", "clay"))
# Export to GIS format...

cat("[OK] Complete SDA workflow done!\n")
```

---

## Troubleshooting

**Problem: "soilDB package required"**
- Solution: Install soilDB with `install.packages("soilDB")` then restart R

**Problem: Query timeout**
- Solution: Increase `timeout` parameter; reduce `tile_size` in optimization

**Problem: Cache outdated**
- Solution: Delete cache directory (default: `~/.cache/geocoda_sda`) or set `use_cache=FALSE`

**Problem: Component percentages don't sum to 100%**
- Solution: Some SSURGO data has missing/null percentages; `gc_process_ssurgo_components()` normalizes automatically

---

## Summary

| Step | Function | Purpose |
|------|----------|---------|
| A | `gc_fetch_sda_properties()` | Query SDA by extent or map units |
| A | `gc_process_ssurgo_components()` | Aggregate components to map units |
| A | `gc_optimize_sda_queries()` | Tile + parallelize large queries |
| A | `gc_prepare_hierarchical_data()` | Combine field + SSURGO, transform to ILR |

**Key takeaways:**
- SSURGO SDA enables cost-effective regional spatial coverage
- Combining field (precise) + SSURGO (extensive) data improves model robustness
- Hierarchical models leverage these combined data sources effectively
- Caching + tiling make large queries practical and efficient

**Next steps:**
- See advanced examples for complex hierarchies with multiple zones
- See CRAN submission guide for deployment and packaging

---

## References

### R Packages

- Beaudette, D., Skovlin, J., Roecker, S., & Brown, A. (2023). soilDB: Soil Database Interface.
  *R package version 2.8.0*. https://CRAN.R-project.org/package=soilDB

  Enables live SSURGO/SDA database queries via gc_prepare_ssurgo_direct() and
  gc_fetch_sda_properties(). Provides access to USDA-NRCS soil survey data for
  integration with field observations.

### Government Data Sources

- Natural Resources Conservation Service. (2024). Soil Survey Geographic (SSURGO) Database.
  U.S. Department of Agriculture.
  https://www.nrcs.usda.gov/resources/data-and-reports/soil-survey-geographic-ssurgo-database

  Primary soil survey database for the United States, providing spatial polygon data and
  soil property estimates. Accessed via gc_prepare_ssurgo_direct() and gc_fetch_sda_properties()
  through the Soil Data Access (SDA) API.

- Natural Resources Conservation Service. (2024). Soil Data Access (SDA) API.
  U.S. Department of Agriculture. https://sdmdataaccess.nrcs.usda.gov/

  Web service API for querying SSURGO database by spatial extent or map unit key. Used by
  geocoda SSURGO integration functions with configurable timeouts, caching, and component
  weighting.

- Soil Survey Division Staff. (2017). Soil Survey Manual.
  U.S. Department of Agriculture Handbook No. 18.
  https://www.nrcs.usda.gov/resources/guides-and-instructions/soil-survey-manual

  Official USDA soil texture classification system defining particle size limits
  (sand: 0.05–2mm, silt: 0.002–0.05mm, clay: <0.002mm) and textural triangle.
  Provides standard constraints used in gc_expand_bounds().
